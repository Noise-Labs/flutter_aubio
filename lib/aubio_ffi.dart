// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Aubio Bindings for Dart & Flutter
class aubio {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  aubio(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  aubio.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// fvec_t buffer creation function
  ///
  /// \param length the length of the buffer to create
  ffi.Pointer<fvec_t> new_fvec(
    int length,
  ) {
    return _new_fvec(
      length,
    );
  }

  late final _new_fvec_ptr =
      _lookup<ffi.NativeFunction<_c_new_fvec>>('new_fvec');
  late final _dart_new_fvec _new_fvec =
      _new_fvec_ptr.asFunction<_dart_new_fvec>();

  /// fvec_t buffer deletion function
  ///
  /// \param s buffer to delete as returned by new_fvec()
  void del_fvec(
    ffi.Pointer<fvec_t> s,
  ) {
    return _del_fvec(
      s,
    );
  }

  late final _del_fvec_ptr =
      _lookup<ffi.NativeFunction<_c_del_fvec>>('del_fvec');
  late final _dart_del_fvec _del_fvec =
      _del_fvec_ptr.asFunction<_dart_del_fvec>();

  /// read sample value in a buffer
  ///
  /// \param s vector to read from
  /// \param position sample position to read from
  double fvec_get_sample(
    ffi.Pointer<fvec_t> s,
    int position,
  ) {
    return _fvec_get_sample(
      s,
      position,
    );
  }

  late final _fvec_get_sample_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_get_sample>>('fvec_get_sample');
  late final _dart_fvec_get_sample _fvec_get_sample =
      _fvec_get_sample_ptr.asFunction<_dart_fvec_get_sample>();

  /// write sample value in a buffer
  ///
  /// \param s vector to write to
  /// \param data value to write in s->data[position]
  /// \param position sample position to write to
  void fvec_set_sample(
    ffi.Pointer<fvec_t> s,
    double data,
    int position,
  ) {
    return _fvec_set_sample(
      s,
      data,
      position,
    );
  }

  late final _fvec_set_sample_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_set_sample>>('fvec_set_sample');
  late final _dart_fvec_set_sample _fvec_set_sample =
      _fvec_set_sample_ptr.asFunction<_dart_fvec_set_sample>();

  /// read data from a buffer
  ///
  /// \param s vector to read from
  ffi.Pointer<ffi.Float> fvec_get_data(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_get_data(
      s,
    );
  }

  late final _fvec_get_data_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_get_data>>('fvec_get_data');
  late final _dart_fvec_get_data _fvec_get_data =
      _fvec_get_data_ptr.asFunction<_dart_fvec_get_data>();

  /// print out fvec data
  ///
  /// \param s vector to print out
  void fvec_print(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_print(
      s,
    );
  }

  late final _fvec_print_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_print>>('fvec_print');
  late final _dart_fvec_print _fvec_print =
      _fvec_print_ptr.asFunction<_dart_fvec_print>();

  /// set all elements to a given value
  ///
  /// \param s vector to modify
  /// \param val value to set elements to
  void fvec_set_all(
    ffi.Pointer<fvec_t> s,
    double val,
  ) {
    return _fvec_set_all(
      s,
      val,
    );
  }

  late final _fvec_set_all_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_set_all>>('fvec_set_all');
  late final _dart_fvec_set_all _fvec_set_all =
      _fvec_set_all_ptr.asFunction<_dart_fvec_set_all>();

  /// set all elements to zero
  ///
  /// \param s vector to modify
  void fvec_zeros(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_zeros(
      s,
    );
  }

  late final _fvec_zeros_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_zeros>>('fvec_zeros');
  late final _dart_fvec_zeros _fvec_zeros =
      _fvec_zeros_ptr.asFunction<_dart_fvec_zeros>();

  /// set all elements to ones
  ///
  /// \param s vector to modify
  void fvec_ones(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_ones(
      s,
    );
  }

  late final _fvec_ones_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_ones>>('fvec_ones');
  late final _dart_fvec_ones _fvec_ones =
      _fvec_ones_ptr.asFunction<_dart_fvec_ones>();

  /// revert order of vector elements
  ///
  /// \param s vector to revert
  void fvec_rev(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_rev(
      s,
    );
  }

  late final _fvec_rev_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_rev>>('fvec_rev');
  late final _dart_fvec_rev _fvec_rev =
      _fvec_rev_ptr.asFunction<_dart_fvec_rev>();

  /// apply weight to vector
  ///
  /// If the weight vector is longer than s, only the first elements are used. If
  /// the weight vector is shorter than s, the last elements of s are not weighted.
  ///
  /// \param s vector to weight
  /// \param weight weighting coefficients
  void fvec_weight(
    ffi.Pointer<fvec_t> s,
    ffi.Pointer<fvec_t> weight,
  ) {
    return _fvec_weight(
      s,
      weight,
    );
  }

  late final _fvec_weight_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_weight>>('fvec_weight');
  late final _dart_fvec_weight _fvec_weight =
      _fvec_weight_ptr.asFunction<_dart_fvec_weight>();

  /// make a copy of a vector
  ///
  /// \param s source vector
  /// \param t vector to copy to
  void fvec_copy(
    ffi.Pointer<fvec_t> s,
    ffi.Pointer<fvec_t> t,
  ) {
    return _fvec_copy(
      s,
      t,
    );
  }

  late final _fvec_copy_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_copy>>('fvec_copy');
  late final _dart_fvec_copy _fvec_copy =
      _fvec_copy_ptr.asFunction<_dart_fvec_copy>();

  /// make a copy of a vector, applying weights to each element
  ///
  /// \param in input vector
  /// \param weight weights vector
  /// \param out output vector
  void fvec_weighted_copy(
    ffi.Pointer<fvec_t> in_1,
    ffi.Pointer<fvec_t> weight,
    ffi.Pointer<fvec_t> out,
  ) {
    return _fvec_weighted_copy(
      in_1,
      weight,
      out,
    );
  }

  late final _fvec_weighted_copy_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_weighted_copy>>('fvec_weighted_copy');
  late final _dart_fvec_weighted_copy _fvec_weighted_copy =
      _fvec_weighted_copy_ptr.asFunction<_dart_fvec_weighted_copy>();

  /// cvec_t buffer creation function
  ///
  /// This function creates a cvec_t structure holding two arrays of size
  /// [length/2+1], corresponding to the norm and phase values of the
  /// spectral frame. The length stored in the structure is the actual size of both
  /// arrays, not the length of the complex and symmetrical vector, specified as
  /// creation argument.
  ///
  /// \param length the length of the buffer to create
  ffi.Pointer<cvec_t> new_cvec(
    int length,
  ) {
    return _new_cvec(
      length,
    );
  }

  late final _new_cvec_ptr =
      _lookup<ffi.NativeFunction<_c_new_cvec>>('new_cvec');
  late final _dart_new_cvec _new_cvec =
      _new_cvec_ptr.asFunction<_dart_new_cvec>();

  /// cvec_t buffer deletion function
  ///
  /// \param s buffer to delete as returned by new_cvec()
  void del_cvec(
    ffi.Pointer<cvec_t> s,
  ) {
    return _del_cvec(
      s,
    );
  }

  late final _del_cvec_ptr =
      _lookup<ffi.NativeFunction<_c_del_cvec>>('del_cvec');
  late final _dart_del_cvec _del_cvec =
      _del_cvec_ptr.asFunction<_dart_del_cvec>();

  /// write norm value in a complex buffer
  ///
  /// This is equivalent to:
  /// \code
  /// s->norm[position] = val;
  /// \endcode
  ///
  /// \param s vector to write to
  /// \param val norm value to write in s->norm[position]
  /// \param position sample position to write to
  void cvec_norm_set_sample(
    ffi.Pointer<cvec_t> s,
    double val,
    int position,
  ) {
    return _cvec_norm_set_sample(
      s,
      val,
      position,
    );
  }

  late final _cvec_norm_set_sample_ptr =
      _lookup<ffi.NativeFunction<_c_cvec_norm_set_sample>>(
          'cvec_norm_set_sample');
  late final _dart_cvec_norm_set_sample _cvec_norm_set_sample =
      _cvec_norm_set_sample_ptr.asFunction<_dart_cvec_norm_set_sample>();

  /// write phase value in a complex buffer
  ///
  /// This is equivalent to:
  /// \code
  /// s->phas[position] = val;
  /// \endcode
  ///
  /// \param s vector to write to
  /// \param val phase value to write in s->phas[position]
  /// \param position sample position to write to
  void cvec_phas_set_sample(
    ffi.Pointer<cvec_t> s,
    double val,
    int position,
  ) {
    return _cvec_phas_set_sample(
      s,
      val,
      position,
    );
  }

  late final _cvec_phas_set_sample_ptr =
      _lookup<ffi.NativeFunction<_c_cvec_phas_set_sample>>(
          'cvec_phas_set_sample');
  late final _dart_cvec_phas_set_sample _cvec_phas_set_sample =
      _cvec_phas_set_sample_ptr.asFunction<_dart_cvec_phas_set_sample>();

  /// read norm value from a complex buffer
  ///
  /// This is equivalent to:
  /// \code
  /// smpl_t foo = s->norm[position];
  /// \endcode
  ///
  /// \param s vector to read from
  /// \param position sample position to read from
  double cvec_norm_get_sample(
    ffi.Pointer<cvec_t> s,
    int position,
  ) {
    return _cvec_norm_get_sample(
      s,
      position,
    );
  }

  late final _cvec_norm_get_sample_ptr =
      _lookup<ffi.NativeFunction<_c_cvec_norm_get_sample>>(
          'cvec_norm_get_sample');
  late final _dart_cvec_norm_get_sample _cvec_norm_get_sample =
      _cvec_norm_get_sample_ptr.asFunction<_dart_cvec_norm_get_sample>();

  /// read phase value from a complex buffer
  ///
  /// This is equivalent to:
  /// \code
  /// smpl_t foo = s->phas[position];
  /// \endcode
  ///
  /// \param s vector to read from
  /// \param position sample position to read from
  /// \returns the value of the sample at position
  double cvec_phas_get_sample(
    ffi.Pointer<cvec_t> s,
    int position,
  ) {
    return _cvec_phas_get_sample(
      s,
      position,
    );
  }

  late final _cvec_phas_get_sample_ptr =
      _lookup<ffi.NativeFunction<_c_cvec_phas_get_sample>>(
          'cvec_phas_get_sample');
  late final _dart_cvec_phas_get_sample _cvec_phas_get_sample =
      _cvec_phas_get_sample_ptr.asFunction<_dart_cvec_phas_get_sample>();

  /// read norm data from a complex buffer
  ///
  /// \code
  /// smpl_t *data = s->norm;
  /// \endcode
  ///
  /// \param s vector to read from
  ffi.Pointer<ffi.Float> cvec_norm_get_data(
    ffi.Pointer<cvec_t> s,
  ) {
    return _cvec_norm_get_data(
      s,
    );
  }

  late final _cvec_norm_get_data_ptr =
      _lookup<ffi.NativeFunction<_c_cvec_norm_get_data>>('cvec_norm_get_data');
  late final _dart_cvec_norm_get_data _cvec_norm_get_data =
      _cvec_norm_get_data_ptr.asFunction<_dart_cvec_norm_get_data>();

  /// read phase data from a complex buffer
  ///
  /// This is equivalent to:
  /// \code
  /// smpl_t *data = s->phas;
  /// \endcode
  ///
  /// \param s vector to read from
  ffi.Pointer<ffi.Float> cvec_phas_get_data(
    ffi.Pointer<cvec_t> s,
  ) {
    return _cvec_phas_get_data(
      s,
    );
  }

  late final _cvec_phas_get_data_ptr =
      _lookup<ffi.NativeFunction<_c_cvec_phas_get_data>>('cvec_phas_get_data');
  late final _dart_cvec_phas_get_data _cvec_phas_get_data =
      _cvec_phas_get_data_ptr.asFunction<_dart_cvec_phas_get_data>();

  /// print out cvec data
  ///
  /// \param s vector to print out
  void cvec_print(
    ffi.Pointer<cvec_t> s,
  ) {
    return _cvec_print(
      s,
    );
  }

  late final _cvec_print_ptr =
      _lookup<ffi.NativeFunction<_c_cvec_print>>('cvec_print');
  late final _dart_cvec_print _cvec_print =
      _cvec_print_ptr.asFunction<_dart_cvec_print>();

  /// make a copy of a vector
  ///
  /// \param s source vector
  /// \param t vector to copy to
  void cvec_copy(
    ffi.Pointer<cvec_t> s,
    ffi.Pointer<cvec_t> t,
  ) {
    return _cvec_copy(
      s,
      t,
    );
  }

  late final _cvec_copy_ptr =
      _lookup<ffi.NativeFunction<_c_cvec_copy>>('cvec_copy');
  late final _dart_cvec_copy _cvec_copy =
      _cvec_copy_ptr.asFunction<_dart_cvec_copy>();

  /// set all norm elements to a given value
  ///
  /// \param s vector to modify
  /// \param val value to set elements to
  void cvec_norm_set_all(
    ffi.Pointer<cvec_t> s,
    double val,
  ) {
    return _cvec_norm_set_all(
      s,
      val,
    );
  }

  late final _cvec_norm_set_all_ptr =
      _lookup<ffi.NativeFunction<_c_cvec_norm_set_all>>('cvec_norm_set_all');
  late final _dart_cvec_norm_set_all _cvec_norm_set_all =
      _cvec_norm_set_all_ptr.asFunction<_dart_cvec_norm_set_all>();

  /// set all norm elements to zero
  ///
  /// \param s vector to modify
  void cvec_norm_zeros(
    ffi.Pointer<cvec_t> s,
  ) {
    return _cvec_norm_zeros(
      s,
    );
  }

  late final _cvec_norm_zeros_ptr =
      _lookup<ffi.NativeFunction<_c_cvec_norm_zeros>>('cvec_norm_zeros');
  late final _dart_cvec_norm_zeros _cvec_norm_zeros =
      _cvec_norm_zeros_ptr.asFunction<_dart_cvec_norm_zeros>();

  /// set all norm elements to one
  ///
  /// \param s vector to modify
  void cvec_norm_ones(
    ffi.Pointer<cvec_t> s,
  ) {
    return _cvec_norm_ones(
      s,
    );
  }

  late final _cvec_norm_ones_ptr =
      _lookup<ffi.NativeFunction<_c_cvec_norm_ones>>('cvec_norm_ones');
  late final _dart_cvec_norm_ones _cvec_norm_ones =
      _cvec_norm_ones_ptr.asFunction<_dart_cvec_norm_ones>();

  /// set all phase elements to a given value
  ///
  /// \param s vector to modify
  /// \param val value to set elements to
  void cvec_phas_set_all(
    ffi.Pointer<cvec_t> s,
    double val,
  ) {
    return _cvec_phas_set_all(
      s,
      val,
    );
  }

  late final _cvec_phas_set_all_ptr =
      _lookup<ffi.NativeFunction<_c_cvec_phas_set_all>>('cvec_phas_set_all');
  late final _dart_cvec_phas_set_all _cvec_phas_set_all =
      _cvec_phas_set_all_ptr.asFunction<_dart_cvec_phas_set_all>();

  /// set all phase elements to zero
  ///
  /// \param s vector to modify
  void cvec_phas_zeros(
    ffi.Pointer<cvec_t> s,
  ) {
    return _cvec_phas_zeros(
      s,
    );
  }

  late final _cvec_phas_zeros_ptr =
      _lookup<ffi.NativeFunction<_c_cvec_phas_zeros>>('cvec_phas_zeros');
  late final _dart_cvec_phas_zeros _cvec_phas_zeros =
      _cvec_phas_zeros_ptr.asFunction<_dart_cvec_phas_zeros>();

  /// set all phase elements to one
  ///
  /// \param s vector to modify
  void cvec_phas_ones(
    ffi.Pointer<cvec_t> s,
  ) {
    return _cvec_phas_ones(
      s,
    );
  }

  late final _cvec_phas_ones_ptr =
      _lookup<ffi.NativeFunction<_c_cvec_phas_ones>>('cvec_phas_ones');
  late final _dart_cvec_phas_ones _cvec_phas_ones =
      _cvec_phas_ones_ptr.asFunction<_dart_cvec_phas_ones>();

  /// set all norm and phas elements to zero
  ///
  /// \param s vector to modify
  void cvec_zeros(
    ffi.Pointer<cvec_t> s,
  ) {
    return _cvec_zeros(
      s,
    );
  }

  late final _cvec_zeros_ptr =
      _lookup<ffi.NativeFunction<_c_cvec_zeros>>('cvec_zeros');
  late final _dart_cvec_zeros _cvec_zeros =
      _cvec_zeros_ptr.asFunction<_dart_cvec_zeros>();

  /// take logarithmic magnitude
  ///
  /// \param s input cvec to compress
  /// \param lambda value to use for normalisation
  ///
  /// \f$ S_k = log( \lambda * S_k + 1 ) \f$
  void cvec_logmag(
    ffi.Pointer<cvec_t> s,
    double lambda,
  ) {
    return _cvec_logmag(
      s,
      lambda,
    );
  }

  late final _cvec_logmag_ptr =
      _lookup<ffi.NativeFunction<_c_cvec_logmag>>('cvec_logmag');
  late final _dart_cvec_logmag _cvec_logmag =
      _cvec_logmag_ptr.asFunction<_dart_cvec_logmag>();

  /// lvec_t buffer creation function
  ///
  /// \param length the length of the buffer to create
  ffi.Pointer<lvec_t> new_lvec(
    int length,
  ) {
    return _new_lvec(
      length,
    );
  }

  late final _new_lvec_ptr =
      _lookup<ffi.NativeFunction<_c_new_lvec>>('new_lvec');
  late final _dart_new_lvec _new_lvec =
      _new_lvec_ptr.asFunction<_dart_new_lvec>();

  /// lvec_t buffer deletion function
  ///
  /// \param s buffer to delete as returned by new_lvec()
  void del_lvec(
    ffi.Pointer<lvec_t> s,
  ) {
    return _del_lvec(
      s,
    );
  }

  late final _del_lvec_ptr =
      _lookup<ffi.NativeFunction<_c_del_lvec>>('del_lvec');
  late final _dart_del_lvec _del_lvec =
      _del_lvec_ptr.asFunction<_dart_del_lvec>();

  /// read sample value in a buffer
  ///
  /// \param s vector to read from
  /// \param position sample position to read from
  double lvec_get_sample(
    ffi.Pointer<lvec_t> s,
    int position,
  ) {
    return _lvec_get_sample(
      s,
      position,
    );
  }

  late final _lvec_get_sample_ptr =
      _lookup<ffi.NativeFunction<_c_lvec_get_sample>>('lvec_get_sample');
  late final _dart_lvec_get_sample _lvec_get_sample =
      _lvec_get_sample_ptr.asFunction<_dart_lvec_get_sample>();

  /// write sample value in a buffer
  ///
  /// \param s vector to write to
  /// \param data value to write in s->data[position]
  /// \param position sample position to write to
  void lvec_set_sample(
    ffi.Pointer<lvec_t> s,
    double data,
    int position,
  ) {
    return _lvec_set_sample(
      s,
      data,
      position,
    );
  }

  late final _lvec_set_sample_ptr =
      _lookup<ffi.NativeFunction<_c_lvec_set_sample>>('lvec_set_sample');
  late final _dart_lvec_set_sample _lvec_set_sample =
      _lvec_set_sample_ptr.asFunction<_dart_lvec_set_sample>();

  /// read data from a buffer
  ///
  /// \param s vector to read from
  ffi.Pointer<ffi.Double> lvec_get_data(
    ffi.Pointer<lvec_t> s,
  ) {
    return _lvec_get_data(
      s,
    );
  }

  late final _lvec_get_data_ptr =
      _lookup<ffi.NativeFunction<_c_lvec_get_data>>('lvec_get_data');
  late final _dart_lvec_get_data _lvec_get_data =
      _lvec_get_data_ptr.asFunction<_dart_lvec_get_data>();

  /// print out lvec data
  ///
  /// \param s vector to print out
  void lvec_print(
    ffi.Pointer<lvec_t> s,
  ) {
    return _lvec_print(
      s,
    );
  }

  late final _lvec_print_ptr =
      _lookup<ffi.NativeFunction<_c_lvec_print>>('lvec_print');
  late final _dart_lvec_print _lvec_print =
      _lvec_print_ptr.asFunction<_dart_lvec_print>();

  /// set all elements to a given value
  ///
  /// \param s vector to modify
  /// \param val value to set elements to
  void lvec_set_all(
    ffi.Pointer<lvec_t> s,
    double val,
  ) {
    return _lvec_set_all(
      s,
      val,
    );
  }

  late final _lvec_set_all_ptr =
      _lookup<ffi.NativeFunction<_c_lvec_set_all>>('lvec_set_all');
  late final _dart_lvec_set_all _lvec_set_all =
      _lvec_set_all_ptr.asFunction<_dart_lvec_set_all>();

  /// set all elements to zero
  ///
  /// \param s vector to modify
  void lvec_zeros(
    ffi.Pointer<lvec_t> s,
  ) {
    return _lvec_zeros(
      s,
    );
  }

  late final _lvec_zeros_ptr =
      _lookup<ffi.NativeFunction<_c_lvec_zeros>>('lvec_zeros');
  late final _dart_lvec_zeros _lvec_zeros =
      _lvec_zeros_ptr.asFunction<_dart_lvec_zeros>();

  /// set all elements to ones
  ///
  /// \param s vector to modify
  void lvec_ones(
    ffi.Pointer<lvec_t> s,
  ) {
    return _lvec_ones(
      s,
    );
  }

  late final _lvec_ones_ptr =
      _lookup<ffi.NativeFunction<_c_lvec_ones>>('lvec_ones');
  late final _dart_lvec_ones _lvec_ones =
      _lvec_ones_ptr.asFunction<_dart_lvec_ones>();

  /// fmat_t buffer creation function
  ///
  /// \param length the length of the matrix to create
  /// \param height the height of the matrix to create
  ffi.Pointer<fmat_t> new_fmat(
    int height,
    int length,
  ) {
    return _new_fmat(
      height,
      length,
    );
  }

  late final _new_fmat_ptr =
      _lookup<ffi.NativeFunction<_c_new_fmat>>('new_fmat');
  late final _dart_new_fmat _new_fmat =
      _new_fmat_ptr.asFunction<_dart_new_fmat>();

  /// fmat_t buffer deletion function
  ///
  /// \param s buffer to delete as returned by new_fmat()
  void del_fmat(
    ffi.Pointer<fmat_t> s,
  ) {
    return _del_fmat(
      s,
    );
  }

  late final _del_fmat_ptr =
      _lookup<ffi.NativeFunction<_c_del_fmat>>('del_fmat');
  late final _dart_del_fmat _del_fmat =
      _del_fmat_ptr.asFunction<_dart_del_fmat>();

  /// read sample value in a buffer
  ///
  /// \param s vector to read from
  /// \param channel channel to read from
  /// \param position sample position to read from
  double fmat_get_sample(
    ffi.Pointer<fmat_t> s,
    int channel,
    int position,
  ) {
    return _fmat_get_sample(
      s,
      channel,
      position,
    );
  }

  late final _fmat_get_sample_ptr =
      _lookup<ffi.NativeFunction<_c_fmat_get_sample>>('fmat_get_sample');
  late final _dart_fmat_get_sample _fmat_get_sample =
      _fmat_get_sample_ptr.asFunction<_dart_fmat_get_sample>();

  /// write sample value in a buffer
  ///
  /// \param s vector to write to
  /// \param data value to write in s->data[channel][position]
  /// \param channel channel to write to
  /// \param position sample position to write to
  void fmat_set_sample(
    ffi.Pointer<fmat_t> s,
    double data,
    int channel,
    int position,
  ) {
    return _fmat_set_sample(
      s,
      data,
      channel,
      position,
    );
  }

  late final _fmat_set_sample_ptr =
      _lookup<ffi.NativeFunction<_c_fmat_set_sample>>('fmat_set_sample');
  late final _dart_fmat_set_sample _fmat_set_sample =
      _fmat_set_sample_ptr.asFunction<_dart_fmat_set_sample>();

  /// read channel vector from a buffer
  ///
  /// \param s vector to read from
  /// \param channel channel to read from
  /// \param output ::fvec_t to output to
  void fmat_get_channel(
    ffi.Pointer<fmat_t> s,
    int channel,
    ffi.Pointer<fvec_t> output,
  ) {
    return _fmat_get_channel(
      s,
      channel,
      output,
    );
  }

  late final _fmat_get_channel_ptr =
      _lookup<ffi.NativeFunction<_c_fmat_get_channel>>('fmat_get_channel');
  late final _dart_fmat_get_channel _fmat_get_channel =
      _fmat_get_channel_ptr.asFunction<_dart_fmat_get_channel>();

  /// get vector buffer from an fmat data
  ///
  /// \param s vector to read from
  /// \param channel channel to read from
  ffi.Pointer<ffi.Float> fmat_get_channel_data(
    ffi.Pointer<fmat_t> s,
    int channel,
  ) {
    return _fmat_get_channel_data(
      s,
      channel,
    );
  }

  late final _fmat_get_channel_data_ptr =
      _lookup<ffi.NativeFunction<_c_fmat_get_channel_data>>(
          'fmat_get_channel_data');
  late final _dart_fmat_get_channel_data _fmat_get_channel_data =
      _fmat_get_channel_data_ptr.asFunction<_dart_fmat_get_channel_data>();

  /// read data from a buffer
  ///
  /// \param s vector to read from
  ffi.Pointer<ffi.Pointer<ffi.Float>> fmat_get_data(
    ffi.Pointer<fmat_t> s,
  ) {
    return _fmat_get_data(
      s,
    );
  }

  late final _fmat_get_data_ptr =
      _lookup<ffi.NativeFunction<_c_fmat_get_data>>('fmat_get_data');
  late final _dart_fmat_get_data _fmat_get_data =
      _fmat_get_data_ptr.asFunction<_dart_fmat_get_data>();

  /// print out fmat data
  ///
  /// \param s vector to print out
  void fmat_print(
    ffi.Pointer<fmat_t> s,
  ) {
    return _fmat_print(
      s,
    );
  }

  late final _fmat_print_ptr =
      _lookup<ffi.NativeFunction<_c_fmat_print>>('fmat_print');
  late final _dart_fmat_print _fmat_print =
      _fmat_print_ptr.asFunction<_dart_fmat_print>();

  /// set all elements to a given value
  ///
  /// \param s vector to modify
  /// \param val value to set elements to
  void fmat_set(
    ffi.Pointer<fmat_t> s,
    double val,
  ) {
    return _fmat_set(
      s,
      val,
    );
  }

  late final _fmat_set_ptr =
      _lookup<ffi.NativeFunction<_c_fmat_set>>('fmat_set');
  late final _dart_fmat_set _fmat_set =
      _fmat_set_ptr.asFunction<_dart_fmat_set>();

  /// set all elements to zero
  ///
  /// \param s vector to modify
  void fmat_zeros(
    ffi.Pointer<fmat_t> s,
  ) {
    return _fmat_zeros(
      s,
    );
  }

  late final _fmat_zeros_ptr =
      _lookup<ffi.NativeFunction<_c_fmat_zeros>>('fmat_zeros');
  late final _dart_fmat_zeros _fmat_zeros =
      _fmat_zeros_ptr.asFunction<_dart_fmat_zeros>();

  /// set all elements to ones
  ///
  /// \param s vector to modify
  void fmat_ones(
    ffi.Pointer<fmat_t> s,
  ) {
    return _fmat_ones(
      s,
    );
  }

  late final _fmat_ones_ptr =
      _lookup<ffi.NativeFunction<_c_fmat_ones>>('fmat_ones');
  late final _dart_fmat_ones _fmat_ones =
      _fmat_ones_ptr.asFunction<_dart_fmat_ones>();

  /// revert order of vector elements
  ///
  /// \param s vector to revert
  void fmat_rev(
    ffi.Pointer<fmat_t> s,
  ) {
    return _fmat_rev(
      s,
    );
  }

  late final _fmat_rev_ptr =
      _lookup<ffi.NativeFunction<_c_fmat_rev>>('fmat_rev');
  late final _dart_fmat_rev _fmat_rev =
      _fmat_rev_ptr.asFunction<_dart_fmat_rev>();

  /// apply weight to vector
  ///
  /// If the weight vector is longer than s, only the first elements are used. If
  /// the weight vector is shorter than s, the last elements of s are not weighted.
  ///
  /// \param s vector to weight
  /// \param weight weighting coefficients
  void fmat_weight(
    ffi.Pointer<fmat_t> s,
    ffi.Pointer<fmat_t> weight,
  ) {
    return _fmat_weight(
      s,
      weight,
    );
  }

  late final _fmat_weight_ptr =
      _lookup<ffi.NativeFunction<_c_fmat_weight>>('fmat_weight');
  late final _dart_fmat_weight _fmat_weight =
      _fmat_weight_ptr.asFunction<_dart_fmat_weight>();

  /// make a copy of a matrix
  ///
  /// \param s source vector
  /// \param t vector to copy to
  void fmat_copy(
    ffi.Pointer<fmat_t> s,
    ffi.Pointer<fmat_t> t,
  ) {
    return _fmat_copy(
      s,
      t,
    );
  }

  late final _fmat_copy_ptr =
      _lookup<ffi.NativeFunction<_c_fmat_copy>>('fmat_copy');
  late final _dart_fmat_copy _fmat_copy =
      _fmat_copy_ptr.asFunction<_dart_fmat_copy>();

  /// compute the product of a matrix by a vector
  ///
  /// \param s matrix to compute product with
  /// \param scale vector to compute product with
  /// \param output vector to store restults in
  void fmat_vecmul(
    ffi.Pointer<fmat_t> s,
    ffi.Pointer<fvec_t> scale,
    ffi.Pointer<fvec_t> output,
  ) {
    return _fmat_vecmul(
      s,
      scale,
      output,
    );
  }

  late final _fmat_vecmul_ptr =
      _lookup<ffi.NativeFunction<_c_fmat_vecmul>>('fmat_vecmul');
  late final _dart_fmat_vecmul _fmat_vecmul =
      _fmat_vecmul_ptr.asFunction<_dart_fmat_vecmul>();

  /// create window
  ///
  /// \param window_type type of the window to create
  /// \param size length of the window to create (see fvec_set_window())
  ffi.Pointer<fvec_t> new_aubio_window(
    ffi.Pointer<ffi.Int8> window_type,
    int size,
  ) {
    return _new_aubio_window(
      window_type,
      size,
    );
  }

  late final _new_aubio_window_ptr =
      _lookup<ffi.NativeFunction<_c_new_aubio_window>>('new_aubio_window');
  late final _dart_new_aubio_window _new_aubio_window =
      _new_aubio_window_ptr.asFunction<_dart_new_aubio_window>();

  /// set elements of a vector to window coefficients
  ///
  /// \param window exsting ::fvec_t to use
  /// \param window_type type of the window to create
  ///
  /// List of available window types: "rectangle", "hamming", "hanning",
  /// "hanningz", "blackman", "blackman_harris", "gaussian", "welch", "parzen",
  /// "default".
  ///
  /// "default" is equivalent to "hanningz".
  ///
  /// References:
  ///
  /// - <a href="http://en.wikipedia.org/wiki/Window_function">Window
  /// function</a> on Wikipedia
  /// - Amalia de Götzen, Nicolas Bernardini, and Daniel Arfib. Traditional (?)
  /// implementations of a phase vocoder: the tricks of the trade. In Proceedings of
  /// the International Conference on Digital Audio Effects (DAFx-00), pages 37–44,
  /// Uni- versity of Verona, Italy, 2000.
  /// (<a href="http://www.cs.princeton.edu/courses/archive/spr09/cos325/Bernardini.pdf">
  /// pdf</a>)
  int fvec_set_window(
    ffi.Pointer<fvec_t> window,
    ffi.Pointer<ffi.Int8> window_type,
  ) {
    return _fvec_set_window(
      window,
      window_type,
    );
  }

  late final _fvec_set_window_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_set_window>>('fvec_set_window');
  late final _dart_fvec_set_window _fvec_set_window =
      _fvec_set_window_ptr.asFunction<_dart_fvec_set_window>();

  /// compute the principal argument
  ///
  /// This function maps the input phase to its corresponding value wrapped in the
  /// range \f$ [-\pi, \pi] \f$.
  ///
  /// \param phase unwrapped phase to map to the unit circle
  ///
  /// \return equivalent phase wrapped to the unit circle
  double aubio_unwrap2pi(
    double phase,
  ) {
    return _aubio_unwrap2pi(
      phase,
    );
  }

  late final _aubio_unwrap2pi_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_unwrap2pi>>('aubio_unwrap2pi');
  late final _dart_aubio_unwrap2pi _aubio_unwrap2pi =
      _aubio_unwrap2pi_ptr.asFunction<_dart_aubio_unwrap2pi>();

  /// convert frequency bin to midi value
  double aubio_bintomidi(
    double bin,
    double samplerate,
    double fftsize,
  ) {
    return _aubio_bintomidi(
      bin,
      samplerate,
      fftsize,
    );
  }

  late final _aubio_bintomidi_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_bintomidi>>('aubio_bintomidi');
  late final _dart_aubio_bintomidi _aubio_bintomidi =
      _aubio_bintomidi_ptr.asFunction<_dart_aubio_bintomidi>();

  /// convert midi value to frequency bin
  double aubio_miditobin(
    double midi,
    double samplerate,
    double fftsize,
  ) {
    return _aubio_miditobin(
      midi,
      samplerate,
      fftsize,
    );
  }

  late final _aubio_miditobin_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_miditobin>>('aubio_miditobin');
  late final _dart_aubio_miditobin _aubio_miditobin =
      _aubio_miditobin_ptr.asFunction<_dart_aubio_miditobin>();

  /// convert frequency bin to frequency (Hz)
  double aubio_bintofreq(
    double bin,
    double samplerate,
    double fftsize,
  ) {
    return _aubio_bintofreq(
      bin,
      samplerate,
      fftsize,
    );
  }

  late final _aubio_bintofreq_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_bintofreq>>('aubio_bintofreq');
  late final _dart_aubio_bintofreq _aubio_bintofreq =
      _aubio_bintofreq_ptr.asFunction<_dart_aubio_bintofreq>();

  /// convert frequency (Hz) to frequency bin
  double aubio_freqtobin(
    double freq,
    double samplerate,
    double fftsize,
  ) {
    return _aubio_freqtobin(
      freq,
      samplerate,
      fftsize,
    );
  }

  late final _aubio_freqtobin_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_freqtobin>>('aubio_freqtobin');
  late final _dart_aubio_freqtobin _aubio_freqtobin =
      _aubio_freqtobin_ptr.asFunction<_dart_aubio_freqtobin>();

  /// convert frequency (Hz) to mel
  ///
  /// \param freq input frequency, in Hz
  ///
  /// \return output mel
  ///
  /// Converts a scalar from the frequency domain to the mel scale using Slaney
  /// Auditory Toolbox's implementation:
  ///
  /// If \f$ f < 1000 \f$, \f$ m = 3 f / 200 \f$.
  ///
  /// If \f$ f >= 1000 \f$, \f$ m = 1000 + 27 \frac{{ln}(f) - ln(1000))}
  /// {{ln}(6400) - ln(1000)}
  /// \f$
  ///
  /// See also
  /// --------
  ///
  /// aubio_meltohz(), aubio_hztomel_htk().
  double aubio_hztomel(
    double freq,
  ) {
    return _aubio_hztomel(
      freq,
    );
  }

  late final _aubio_hztomel_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_hztomel>>('aubio_hztomel');
  late final _dart_aubio_hztomel _aubio_hztomel =
      _aubio_hztomel_ptr.asFunction<_dart_aubio_hztomel>();

  /// convert mel to frequency (Hz)
  ///
  /// \param mel input mel
  ///
  /// \return output frequency, in Hz
  ///
  /// Converts a scalar from the mel scale to the frequency domain using Slaney
  /// Auditory Toolbox's implementation:
  ///
  /// If \f$ f < 1000 \f$, \f$ f = 200 m/3 \f$.
  ///
  /// If \f$ f \geq 1000 \f$, \f$ f = 1000 + \left(\frac{6400}{1000}\right)
  /// ^{\frac{m - 1000}{27}} \f$
  ///
  /// See also
  /// --------
  ///
  /// aubio_hztomel(), aubio_meltohz_htk().
  ///
  /// References
  /// ----------
  ///
  /// Malcolm Slaney, *Auditory Toolbox Version 2, Technical Report #1998-010*
  /// https://engineering.purdue.edu/~malcolm/interval/1998-010/
  double aubio_meltohz(
    double mel,
  ) {
    return _aubio_meltohz(
      mel,
    );
  }

  late final _aubio_meltohz_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_meltohz>>('aubio_meltohz');
  late final _dart_aubio_meltohz _aubio_meltohz =
      _aubio_meltohz_ptr.asFunction<_dart_aubio_meltohz>();

  /// convert frequency (Hz) to mel
  ///
  /// \param freq input frequency, in Hz
  ///
  /// \return output mel
  ///
  /// Converts a scalar from the frequency domain to the mel scale, using the
  /// equation defined by O'Shaughnessy, as implemented in the HTK speech
  /// recognition toolkit:
  ///
  /// \f$ m = 1127 + ln(1 + \frac{f}{700}) \f$
  ///
  /// See also
  /// --------
  ///
  /// aubio_meltohz_htk(), aubio_hztomel().
  ///
  /// References
  /// ----------
  ///
  /// Douglas O'Shaughnessy (1987). *Speech communication: human and machine*.
  /// Addison-Wesley. p. 150. ISBN 978-0-201-16520-3.
  ///
  /// HTK Speech Recognition Toolkit: http://htk.eng.cam.ac.uk/
  double aubio_hztomel_htk(
    double freq,
  ) {
    return _aubio_hztomel_htk(
      freq,
    );
  }

  late final _aubio_hztomel_htk_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_hztomel_htk>>('aubio_hztomel_htk');
  late final _dart_aubio_hztomel_htk _aubio_hztomel_htk =
      _aubio_hztomel_htk_ptr.asFunction<_dart_aubio_hztomel_htk>();

  /// convert mel to frequency (Hz)
  ///
  /// \param mel input mel
  ///
  /// \return output frequency, in Hz
  ///
  /// Converts a scalar from the mel scale to the frequency domain, using the
  /// equation defined by O'Shaughnessy, as implemented in the HTK speech
  /// recognition toolkit:
  ///
  /// \f$ f = 700 * {e}^\left(\frac{f}{1127} - 1\right) \f$
  ///
  /// See also
  /// --------
  ///
  /// aubio_hztomel_htk(), aubio_meltohz().
  double aubio_meltohz_htk(
    double mel,
  ) {
    return _aubio_meltohz_htk(
      mel,
    );
  }

  late final _aubio_meltohz_htk_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_meltohz_htk>>('aubio_meltohz_htk');
  late final _dart_aubio_meltohz_htk _aubio_meltohz_htk =
      _aubio_meltohz_htk_ptr.asFunction<_dart_aubio_meltohz_htk>();

  /// convert frequency (Hz) to midi value (0-128)
  double aubio_freqtomidi(
    double freq,
  ) {
    return _aubio_freqtomidi(
      freq,
    );
  }

  late final _aubio_freqtomidi_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_freqtomidi>>('aubio_freqtomidi');
  late final _dart_aubio_freqtomidi _aubio_freqtomidi =
      _aubio_freqtomidi_ptr.asFunction<_dart_aubio_freqtomidi>();

  /// convert midi value (0-128) to frequency (Hz)
  double aubio_miditofreq(
    double midi,
  ) {
    return _aubio_miditofreq(
      midi,
    );
  }

  late final _aubio_miditofreq_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_miditofreq>>('aubio_miditofreq');
  late final _dart_aubio_miditofreq _aubio_miditofreq =
      _aubio_miditofreq_ptr.asFunction<_dart_aubio_miditofreq>();

  /// clean up cached memory at the end of program
  ///
  /// This function should be used at the end of programs to purge all cached
  /// memory. So far it is only useful to clean FFTW's cache.
  void aubio_cleanup() {
    return _aubio_cleanup();
  }

  late final _aubio_cleanup_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_cleanup>>('aubio_cleanup');
  late final _dart_aubio_cleanup _aubio_cleanup =
      _aubio_cleanup_ptr.asFunction<_dart_aubio_cleanup>();

  /// zero-crossing rate (ZCR)
  ///
  /// The zero-crossing rate is the number of times a signal changes sign,
  /// divided by the length of this signal.
  ///
  /// \param v vector to compute ZCR from
  ///
  /// \return zero-crossing rate of v
  double aubio_zero_crossing_rate(
    ffi.Pointer<fvec_t> v,
  ) {
    return _aubio_zero_crossing_rate(
      v,
    );
  }

  late final _aubio_zero_crossing_rate_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_zero_crossing_rate>>(
          'aubio_zero_crossing_rate');
  late final _dart_aubio_zero_crossing_rate _aubio_zero_crossing_rate =
      _aubio_zero_crossing_rate_ptr
          .asFunction<_dart_aubio_zero_crossing_rate>();

  /// compute sound level on a linear scale
  ///
  /// This gives the average of the square amplitudes.
  ///
  /// \param v vector to compute level from
  ///
  /// \return level of v
  double aubio_level_lin(
    ffi.Pointer<fvec_t> v,
  ) {
    return _aubio_level_lin(
      v,
    );
  }

  late final _aubio_level_lin_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_level_lin>>('aubio_level_lin');
  late final _dart_aubio_level_lin _aubio_level_lin =
      _aubio_level_lin_ptr.asFunction<_dart_aubio_level_lin>();

  /// compute sound pressure level (SPL) in dB
  ///
  /// This quantity is often wrongly called 'loudness'.
  ///
  /// This gives ten times the log10 of the average of the square amplitudes.
  ///
  /// \param v vector to compute dB SPL from
  ///
  /// \return level of v in dB SPL
  double aubio_db_spl(
    ffi.Pointer<fvec_t> v,
  ) {
    return _aubio_db_spl(
      v,
    );
  }

  late final _aubio_db_spl_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_db_spl>>('aubio_db_spl');
  late final _dart_aubio_db_spl _aubio_db_spl =
      _aubio_db_spl_ptr.asFunction<_dart_aubio_db_spl>();

  /// check if buffer level in dB SPL is under a given threshold
  ///
  /// \param v vector to get level from
  /// \param threshold threshold in dB SPL
  ///
  /// \return 1 if level is under the given threshold, 0 otherwise
  int aubio_silence_detection(
    ffi.Pointer<fvec_t> v,
    double threshold,
  ) {
    return _aubio_silence_detection(
      v,
      threshold,
    );
  }

  late final _aubio_silence_detection_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_silence_detection>>(
          'aubio_silence_detection');
  late final _dart_aubio_silence_detection _aubio_silence_detection =
      _aubio_silence_detection_ptr.asFunction<_dart_aubio_silence_detection>();

  /// get buffer level if level >= threshold, 1. otherwise
  ///
  /// \param v vector to get level from
  /// \param threshold threshold in dB SPL
  ///
  /// \return level in dB SPL if level >= threshold, 1. otherwise
  double aubio_level_detection(
    ffi.Pointer<fvec_t> v,
    double threshold,
  ) {
    return _aubio_level_detection(
      v,
      threshold,
    );
  }

  late final _aubio_level_detection_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_level_detection>>(
          'aubio_level_detection');
  late final _dart_aubio_level_detection _aubio_level_detection =
      _aubio_level_detection_ptr.asFunction<_dart_aubio_level_detection>();

  /// clamp the values of a vector within the range [-abs(max), abs(max)]
  ///
  /// \param in vector to clamp
  /// \param absmax maximum value over which input vector elements should be clamped
  void fvec_clamp(
    ffi.Pointer<fvec_t> in_1,
    double absmax,
  ) {
    return _fvec_clamp(
      in_1,
      absmax,
    );
  }

  late final _fvec_clamp_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_clamp>>('fvec_clamp');
  late final _dart_fvec_clamp _fvec_clamp =
      _fvec_clamp_ptr.asFunction<_dart_fvec_clamp>();

  /// compute \f$e^x\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_exp(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_exp(
      s,
    );
  }

  late final _fvec_exp_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_exp>>('fvec_exp');
  late final _dart_fvec_exp _fvec_exp =
      _fvec_exp_ptr.asFunction<_dart_fvec_exp>();

  /// compute \f$cos(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_cos(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_cos(
      s,
    );
  }

  late final _fvec_cos_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_cos>>('fvec_cos');
  late final _dart_fvec_cos _fvec_cos =
      _fvec_cos_ptr.asFunction<_dart_fvec_cos>();

  /// compute \f$sin(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_sin(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_sin(
      s,
    );
  }

  late final _fvec_sin_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_sin>>('fvec_sin');
  late final _dart_fvec_sin _fvec_sin =
      _fvec_sin_ptr.asFunction<_dart_fvec_sin>();

  /// compute the \f$abs(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_abs(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_abs(
      s,
    );
  }

  late final _fvec_abs_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_abs>>('fvec_abs');
  late final _dart_fvec_abs _fvec_abs =
      _fvec_abs_ptr.asFunction<_dart_fvec_abs>();

  /// compute the \f$sqrt(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_sqrt(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_sqrt(
      s,
    );
  }

  late final _fvec_sqrt_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_sqrt>>('fvec_sqrt');
  late final _dart_fvec_sqrt _fvec_sqrt =
      _fvec_sqrt_ptr.asFunction<_dart_fvec_sqrt>();

  /// compute the \f$log10(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_log10(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_log10(
      s,
    );
  }

  late final _fvec_log10_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_log10>>('fvec_log10');
  late final _dart_fvec_log10 _fvec_log10 =
      _fvec_log10_ptr.asFunction<_dart_fvec_log10>();

  /// compute the \f$log(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_log(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_log(
      s,
    );
  }

  late final _fvec_log_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_log>>('fvec_log');
  late final _dart_fvec_log _fvec_log =
      _fvec_log_ptr.asFunction<_dart_fvec_log>();

  /// compute the \f$floor(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_floor(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_floor(
      s,
    );
  }

  late final _fvec_floor_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_floor>>('fvec_floor');
  late final _dart_fvec_floor _fvec_floor =
      _fvec_floor_ptr.asFunction<_dart_fvec_floor>();

  /// compute the \f$ceil(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_ceil(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_ceil(
      s,
    );
  }

  late final _fvec_ceil_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_ceil>>('fvec_ceil');
  late final _dart_fvec_ceil _fvec_ceil =
      _fvec_ceil_ptr.asFunction<_dart_fvec_ceil>();

  /// compute the \f$round(x)\f$ of each vector elements
  ///
  /// \param s vector to modify
  void fvec_round(
    ffi.Pointer<fvec_t> s,
  ) {
    return _fvec_round(
      s,
    );
  }

  late final _fvec_round_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_round>>('fvec_round');
  late final _dart_fvec_round _fvec_round =
      _fvec_round_ptr.asFunction<_dart_fvec_round>();

  /// raise each vector elements to the power pow
  ///
  /// \param s vector to modify
  /// \param pow power to raise to
  void fvec_pow(
    ffi.Pointer<fvec_t> s,
    double pow,
  ) {
    return _fvec_pow(
      s,
      pow,
    );
  }

  late final _fvec_pow_ptr =
      _lookup<ffi.NativeFunction<_c_fvec_pow>>('fvec_pow');
  late final _dart_fvec_pow _fvec_pow =
      _fvec_pow_ptr.asFunction<_dart_fvec_pow>();

  /// create resampler object
  ///
  /// \param ratio output_sample_rate / input_sample_rate
  /// \param type libsamplerate resampling type, see http://www.mega-nerd.com/SRC/api_misc.html#Converters
  ffi.Pointer<_aubio_resampler_t> new_aubio_resampler(
    double ratio,
    int type,
  ) {
    return _new_aubio_resampler(
      ratio,
      type,
    );
  }

  late final _new_aubio_resampler_ptr =
      _lookup<ffi.NativeFunction<_c_new_aubio_resampler>>(
          'new_aubio_resampler');
  late final _dart_new_aubio_resampler _new_aubio_resampler =
      _new_aubio_resampler_ptr.asFunction<_dart_new_aubio_resampler>();

  /// delete resampler object
  void del_aubio_resampler(
    ffi.Pointer<_aubio_resampler_t> s,
  ) {
    return _del_aubio_resampler(
      s,
    );
  }

  late final _del_aubio_resampler_ptr =
      _lookup<ffi.NativeFunction<_c_del_aubio_resampler>>(
          'del_aubio_resampler');
  late final _dart_del_aubio_resampler _del_aubio_resampler =
      _del_aubio_resampler_ptr.asFunction<_dart_del_aubio_resampler>();

  /// resample input in output
  ///
  /// \param s resampler object
  /// \param input input buffer of size N
  /// \param output output buffer of size N*ratio
  void aubio_resampler_do(
    ffi.Pointer<_aubio_resampler_t> s,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> output,
  ) {
    return _aubio_resampler_do(
      s,
      input,
      output,
    );
  }

  late final _aubio_resampler_do_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_resampler_do>>('aubio_resampler_do');
  late final _dart_aubio_resampler_do _aubio_resampler_do =
      _aubio_resampler_do_ptr.asFunction<_dart_aubio_resampler_do>();

  /// filter input vector (in-place)
  ///
  /// \param f filter object as returned by new_aubio_filter()
  /// \param in input vector to filter
  void aubio_filter_do(
    ffi.Pointer<_aubio_filter_t> f,
    ffi.Pointer<fvec_t> in_1,
  ) {
    return _aubio_filter_do(
      f,
      in_1,
    );
  }

  late final _aubio_filter_do_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_filter_do>>('aubio_filter_do');
  late final _dart_aubio_filter_do _aubio_filter_do =
      _aubio_filter_do_ptr.asFunction<_dart_aubio_filter_do>();

  /// filter input vector (out-of-place)
  ///
  /// \param f filter object as returned by new_aubio_filter()
  /// \param in input vector to filter
  /// \param out output vector to store filtered input
  void aubio_filter_do_outplace(
    ffi.Pointer<_aubio_filter_t> f,
    ffi.Pointer<fvec_t> in_1,
    ffi.Pointer<fvec_t> out,
  ) {
    return _aubio_filter_do_outplace(
      f,
      in_1,
      out,
    );
  }

  late final _aubio_filter_do_outplace_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_filter_do_outplace>>(
          'aubio_filter_do_outplace');
  late final _dart_aubio_filter_do_outplace _aubio_filter_do_outplace =
      _aubio_filter_do_outplace_ptr
          .asFunction<_dart_aubio_filter_do_outplace>();

  /// filter input vector forward and backward
  ///
  /// \param f ::aubio_filter_t object as returned by new_aubio_filter()
  /// \param in ::fvec_t input vector to filter
  /// \param tmp memory space to use for computation
  void aubio_filter_do_filtfilt(
    ffi.Pointer<_aubio_filter_t> f,
    ffi.Pointer<fvec_t> in_1,
    ffi.Pointer<fvec_t> tmp,
  ) {
    return _aubio_filter_do_filtfilt(
      f,
      in_1,
      tmp,
    );
  }

  late final _aubio_filter_do_filtfilt_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_filter_do_filtfilt>>(
          'aubio_filter_do_filtfilt');
  late final _dart_aubio_filter_do_filtfilt _aubio_filter_do_filtfilt =
      _aubio_filter_do_filtfilt_ptr
          .asFunction<_dart_aubio_filter_do_filtfilt>();

  /// returns a pointer to feedback coefficients \f$ a_i \f$
  ///
  /// \param f filter object to get parameters from
  ///
  /// \return a pointer to the \f$ a_0 ... a_i ... a_P \f$ coefficients
  ffi.Pointer<lvec_t> aubio_filter_get_feedback(
    ffi.Pointer<_aubio_filter_t> f,
  ) {
    return _aubio_filter_get_feedback(
      f,
    );
  }

  late final _aubio_filter_get_feedback_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_filter_get_feedback>>(
          'aubio_filter_get_feedback');
  late final _dart_aubio_filter_get_feedback _aubio_filter_get_feedback =
      _aubio_filter_get_feedback_ptr
          .asFunction<_dart_aubio_filter_get_feedback>();

  /// returns a pointer to feedforward coefficients \f$ b_i \f$
  ///
  /// \param f filter object to get coefficients from
  ///
  /// \return a pointer to the \f$ b_0 ... b_i ... b_P \f$ coefficients
  ffi.Pointer<lvec_t> aubio_filter_get_feedforward(
    ffi.Pointer<_aubio_filter_t> f,
  ) {
    return _aubio_filter_get_feedforward(
      f,
    );
  }

  late final _aubio_filter_get_feedforward_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_filter_get_feedforward>>(
          'aubio_filter_get_feedforward');
  late final _dart_aubio_filter_get_feedforward _aubio_filter_get_feedforward =
      _aubio_filter_get_feedforward_ptr
          .asFunction<_dart_aubio_filter_get_feedforward>();

  /// get order of the filter
  ///
  /// \param f filter to get order from
  ///
  /// \return the order of the filter
  int aubio_filter_get_order(
    ffi.Pointer<_aubio_filter_t> f,
  ) {
    return _aubio_filter_get_order(
      f,
    );
  }

  late final _aubio_filter_get_order_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_filter_get_order>>(
          'aubio_filter_get_order');
  late final _dart_aubio_filter_get_order _aubio_filter_get_order =
      _aubio_filter_get_order_ptr.asFunction<_dart_aubio_filter_get_order>();

  /// get sampling rate of the filter
  ///
  /// \param f filter to get sampling rate from
  ///
  /// \return the sampling rate of the filter, in Hz
  int aubio_filter_get_samplerate(
    ffi.Pointer<_aubio_filter_t> f,
  ) {
    return _aubio_filter_get_samplerate(
      f,
    );
  }

  late final _aubio_filter_get_samplerate_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_filter_get_samplerate>>(
          'aubio_filter_get_samplerate');
  late final _dart_aubio_filter_get_samplerate _aubio_filter_get_samplerate =
      _aubio_filter_get_samplerate_ptr
          .asFunction<_dart_aubio_filter_get_samplerate>();

  /// get sampling rate of the filter
  ///
  /// \param f filter to get sampling rate from
  /// \param samplerate sample rate to set the filter to
  ///
  /// \return the sampling rate of the filter, in Hz
  int aubio_filter_set_samplerate(
    ffi.Pointer<_aubio_filter_t> f,
    int samplerate,
  ) {
    return _aubio_filter_set_samplerate(
      f,
      samplerate,
    );
  }

  late final _aubio_filter_set_samplerate_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_filter_set_samplerate>>(
          'aubio_filter_set_samplerate');
  late final _dart_aubio_filter_set_samplerate _aubio_filter_set_samplerate =
      _aubio_filter_set_samplerate_ptr
          .asFunction<_dart_aubio_filter_set_samplerate>();

  /// reset filter memory
  ///
  /// \param f filter object as returned by new_aubio_filter()
  void aubio_filter_do_reset(
    ffi.Pointer<_aubio_filter_t> f,
  ) {
    return _aubio_filter_do_reset(
      f,
    );
  }

  late final _aubio_filter_do_reset_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_filter_do_reset>>(
          'aubio_filter_do_reset');
  late final _dart_aubio_filter_do_reset _aubio_filter_do_reset =
      _aubio_filter_do_reset_ptr.asFunction<_dart_aubio_filter_do_reset>();

  /// create new filter object
  ///
  /// This function creates a new ::aubio_filter_t object, given the order of the
  /// filter.
  ///
  /// \param order order of the filter (number of coefficients)
  ///
  /// \return the newly created filter object
  ffi.Pointer<_aubio_filter_t> new_aubio_filter(
    int order,
  ) {
    return _new_aubio_filter(
      order,
    );
  }

  late final _new_aubio_filter_ptr =
      _lookup<ffi.NativeFunction<_c_new_aubio_filter>>('new_aubio_filter');
  late final _dart_new_aubio_filter _new_aubio_filter =
      _new_aubio_filter_ptr.asFunction<_dart_new_aubio_filter>();

  /// delete a filter object
  ///
  /// \param f filter object to delete
  void del_aubio_filter(
    ffi.Pointer<_aubio_filter_t> f,
  ) {
    return _del_aubio_filter(
      f,
    );
  }

  late final _del_aubio_filter_ptr =
      _lookup<ffi.NativeFunction<_c_del_aubio_filter>>('del_aubio_filter');
  late final _dart_del_aubio_filter _del_aubio_filter =
      _del_aubio_filter_ptr.asFunction<_dart_del_aubio_filter>();

  /// set coefficients of a biquad filter
  ///
  /// \param f filter object as returned by new_aubio_filter()
  /// \param b0 forward filter coefficient
  /// \param b1 forward filter coefficient
  /// \param b2 forward filter coefficient
  /// \param a1 feedback filter coefficient
  /// \param a2 feedback filter coefficient
  int aubio_filter_set_biquad(
    ffi.Pointer<_aubio_filter_t> f,
    double b0,
    double b1,
    double b2,
    double a1,
    double a2,
  ) {
    return _aubio_filter_set_biquad(
      f,
      b0,
      b1,
      b2,
      a1,
      a2,
    );
  }

  late final _aubio_filter_set_biquad_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_filter_set_biquad>>(
          'aubio_filter_set_biquad');
  late final _dart_aubio_filter_set_biquad _aubio_filter_set_biquad =
      _aubio_filter_set_biquad_ptr.asFunction<_dart_aubio_filter_set_biquad>();

  /// create biquad filter with `b0`, `b1`, `b2`, `a1`, `a2` coeffs
  ///
  /// \param b0 forward filter coefficient
  /// \param b1 forward filter coefficient
  /// \param b2 forward filter coefficient
  /// \param a1 feedback filter coefficient
  /// \param a2 feedback filter coefficient
  ffi.Pointer<_aubio_filter_t> new_aubio_filter_biquad(
    double b0,
    double b1,
    double b2,
    double a1,
    double a2,
  ) {
    return _new_aubio_filter_biquad(
      b0,
      b1,
      b2,
      a1,
      a2,
    );
  }

  late final _new_aubio_filter_biquad_ptr =
      _lookup<ffi.NativeFunction<_c_new_aubio_filter_biquad>>(
          'new_aubio_filter_biquad');
  late final _dart_new_aubio_filter_biquad _new_aubio_filter_biquad =
      _new_aubio_filter_biquad_ptr.asFunction<_dart_new_aubio_filter_biquad>();

  /// create new A-design filter
  ///
  /// \param samplerate sampling frequency of the signal to filter. Should be one of
  /// 8000, 11025, 16000, 22050, 24000, 32000, 44100, 48000, 88200, 96000, and
  /// 192000 Hz
  ///
  /// \return a new filter object
  ffi.Pointer<_aubio_filter_t> new_aubio_filter_a_weighting(
    int samplerate,
  ) {
    return _new_aubio_filter_a_weighting(
      samplerate,
    );
  }

  late final _new_aubio_filter_a_weighting_ptr =
      _lookup<ffi.NativeFunction<_c_new_aubio_filter_a_weighting>>(
          'new_aubio_filter_a_weighting');
  late final _dart_new_aubio_filter_a_weighting _new_aubio_filter_a_weighting =
      _new_aubio_filter_a_weighting_ptr
          .asFunction<_dart_new_aubio_filter_a_weighting>();

  /// set feedback and feedforward coefficients of a A-weighting filter
  ///
  /// \param f filter object to get coefficients from
  /// \param samplerate sampling frequency of the signal to filter. Should be one of
  /// 8000, 11025, 16000, 22050, 24000, 32000, 44100, 48000, 88200, 96000, and
  /// 192000 Hz
  int aubio_filter_set_a_weighting(
    ffi.Pointer<_aubio_filter_t> f,
    int samplerate,
  ) {
    return _aubio_filter_set_a_weighting(
      f,
      samplerate,
    );
  }

  late final _aubio_filter_set_a_weighting_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_filter_set_a_weighting>>(
          'aubio_filter_set_a_weighting');
  late final _dart_aubio_filter_set_a_weighting _aubio_filter_set_a_weighting =
      _aubio_filter_set_a_weighting_ptr
          .asFunction<_dart_aubio_filter_set_a_weighting>();

  /// create new C-design filter
  ///
  /// \param samplerate sampling frequency of the signal to filter. Should be one of
  /// 8000, 11025, 16000, 22050, 24000, 32000, 44100, 48000, 88200, 96000, and
  /// 192000 Hz
  ///
  /// \return a new filter object
  ffi.Pointer<_aubio_filter_t> new_aubio_filter_c_weighting(
    int samplerate,
  ) {
    return _new_aubio_filter_c_weighting(
      samplerate,
    );
  }

  late final _new_aubio_filter_c_weighting_ptr =
      _lookup<ffi.NativeFunction<_c_new_aubio_filter_c_weighting>>(
          'new_aubio_filter_c_weighting');
  late final _dart_new_aubio_filter_c_weighting _new_aubio_filter_c_weighting =
      _new_aubio_filter_c_weighting_ptr
          .asFunction<_dart_new_aubio_filter_c_weighting>();

  /// set feedback and feedforward coefficients of a C-weighting filter
  ///
  /// \param f filter object to get coefficients from
  /// \param samplerate sampling frequency of the signal to filter. Should be one of
  /// 8000, 11025, 16000, 22050, 24000, 32000, 44100, 48000, 88200, 96000, and
  /// 192000 Hz
  int aubio_filter_set_c_weighting(
    ffi.Pointer<_aubio_filter_t> f,
    int samplerate,
  ) {
    return _aubio_filter_set_c_weighting(
      f,
      samplerate,
    );
  }

  late final _aubio_filter_set_c_weighting_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_filter_set_c_weighting>>(
          'aubio_filter_set_c_weighting');
  late final _dart_aubio_filter_set_c_weighting _aubio_filter_set_c_weighting =
      _aubio_filter_set_c_weighting_ptr
          .asFunction<_dart_aubio_filter_set_c_weighting>();

  /// create new FFT computation object
  ///
  /// \param size length of the FFT
  ffi.Pointer<_aubio_fft_t> new_aubio_fft(
    int size,
  ) {
    return _new_aubio_fft(
      size,
    );
  }

  late final _new_aubio_fft_ptr =
      _lookup<ffi.NativeFunction<_c_new_aubio_fft>>('new_aubio_fft');
  late final _dart_new_aubio_fft _new_aubio_fft =
      _new_aubio_fft_ptr.asFunction<_dart_new_aubio_fft>();

  /// delete FFT object
  ///
  /// \param s fft object as returned by new_aubio_fft
  void del_aubio_fft(
    ffi.Pointer<_aubio_fft_t> s,
  ) {
    return _del_aubio_fft(
      s,
    );
  }

  late final _del_aubio_fft_ptr =
      _lookup<ffi.NativeFunction<_c_del_aubio_fft>>('del_aubio_fft');
  late final _dart_del_aubio_fft _del_aubio_fft =
      _del_aubio_fft_ptr.asFunction<_dart_del_aubio_fft>();

  /// compute forward FFT
  ///
  /// \param s fft object as returned by new_aubio_fft
  /// \param input input signal
  /// \param spectrum output spectrum
  void aubio_fft_do(
    ffi.Pointer<_aubio_fft_t> s,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<cvec_t> spectrum,
  ) {
    return _aubio_fft_do(
      s,
      input,
      spectrum,
    );
  }

  late final _aubio_fft_do_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_fft_do>>('aubio_fft_do');
  late final _dart_aubio_fft_do _aubio_fft_do =
      _aubio_fft_do_ptr.asFunction<_dart_aubio_fft_do>();

  /// compute backward (inverse) FFT
  ///
  /// \param s fft object as returned by new_aubio_fft
  /// \param spectrum input spectrum
  /// \param output output signal
  void aubio_fft_rdo(
    ffi.Pointer<_aubio_fft_t> s,
    ffi.Pointer<cvec_t> spectrum,
    ffi.Pointer<fvec_t> output,
  ) {
    return _aubio_fft_rdo(
      s,
      spectrum,
      output,
    );
  }

  late final _aubio_fft_rdo_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_fft_rdo>>('aubio_fft_rdo');
  late final _dart_aubio_fft_rdo _aubio_fft_rdo =
      _aubio_fft_rdo_ptr.asFunction<_dart_aubio_fft_rdo>();

  /// compute forward FFT
  ///
  /// \param s fft object as returned by new_aubio_fft
  /// \param input real input signal
  /// \param compspec complex output fft real/imag
  void aubio_fft_do_complex(
    ffi.Pointer<_aubio_fft_t> s,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> compspec,
  ) {
    return _aubio_fft_do_complex(
      s,
      input,
      compspec,
    );
  }

  late final _aubio_fft_do_complex_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_fft_do_complex>>(
          'aubio_fft_do_complex');
  late final _dart_aubio_fft_do_complex _aubio_fft_do_complex =
      _aubio_fft_do_complex_ptr.asFunction<_dart_aubio_fft_do_complex>();

  /// compute backward (inverse) FFT from real/imag
  ///
  /// \param s fft object as returned by new_aubio_fft
  /// \param compspec real/imag input fft array
  /// \param output real output array
  void aubio_fft_rdo_complex(
    ffi.Pointer<_aubio_fft_t> s,
    ffi.Pointer<fvec_t> compspec,
    ffi.Pointer<fvec_t> output,
  ) {
    return _aubio_fft_rdo_complex(
      s,
      compspec,
      output,
    );
  }

  late final _aubio_fft_rdo_complex_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_fft_rdo_complex>>(
          'aubio_fft_rdo_complex');
  late final _dart_aubio_fft_rdo_complex _aubio_fft_rdo_complex =
      _aubio_fft_rdo_complex_ptr.asFunction<_dart_aubio_fft_rdo_complex>();

  /// convert real/imag spectrum to norm/phas spectrum
  ///
  /// \param compspec real/imag input fft array
  /// \param spectrum cvec norm/phas output array
  void aubio_fft_get_spectrum(
    ffi.Pointer<fvec_t> compspec,
    ffi.Pointer<cvec_t> spectrum,
  ) {
    return _aubio_fft_get_spectrum(
      compspec,
      spectrum,
    );
  }

  late final _aubio_fft_get_spectrum_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_fft_get_spectrum>>(
          'aubio_fft_get_spectrum');
  late final _dart_aubio_fft_get_spectrum _aubio_fft_get_spectrum =
      _aubio_fft_get_spectrum_ptr.asFunction<_dart_aubio_fft_get_spectrum>();

  /// convert real/imag spectrum to norm/phas spectrum
  ///
  /// \param compspec real/imag input fft array
  /// \param spectrum cvec norm/phas output array
  void aubio_fft_get_realimag(
    ffi.Pointer<cvec_t> spectrum,
    ffi.Pointer<fvec_t> compspec,
  ) {
    return _aubio_fft_get_realimag(
      spectrum,
      compspec,
    );
  }

  late final _aubio_fft_get_realimag_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_fft_get_realimag>>(
          'aubio_fft_get_realimag');
  late final _dart_aubio_fft_get_realimag _aubio_fft_get_realimag =
      _aubio_fft_get_realimag_ptr.asFunction<_dart_aubio_fft_get_realimag>();

  /// compute phas spectrum from real/imag parts
  ///
  /// \param compspec real/imag input fft array
  /// \param spectrum cvec norm/phas output array
  void aubio_fft_get_phas(
    ffi.Pointer<fvec_t> compspec,
    ffi.Pointer<cvec_t> spectrum,
  ) {
    return _aubio_fft_get_phas(
      compspec,
      spectrum,
    );
  }

  late final _aubio_fft_get_phas_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_fft_get_phas>>('aubio_fft_get_phas');
  late final _dart_aubio_fft_get_phas _aubio_fft_get_phas =
      _aubio_fft_get_phas_ptr.asFunction<_dart_aubio_fft_get_phas>();

  /// compute imaginary part from the norm/phas cvec
  ///
  /// \param spectrum norm/phas input array
  /// \param compspec real/imag output fft array
  void aubio_fft_get_imag(
    ffi.Pointer<cvec_t> spectrum,
    ffi.Pointer<fvec_t> compspec,
  ) {
    return _aubio_fft_get_imag(
      spectrum,
      compspec,
    );
  }

  late final _aubio_fft_get_imag_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_fft_get_imag>>('aubio_fft_get_imag');
  late final _dart_aubio_fft_get_imag _aubio_fft_get_imag =
      _aubio_fft_get_imag_ptr.asFunction<_dart_aubio_fft_get_imag>();

  /// compute norm component from real/imag parts
  ///
  /// \param compspec real/imag input fft array
  /// \param spectrum cvec norm/phas output array
  void aubio_fft_get_norm(
    ffi.Pointer<fvec_t> compspec,
    ffi.Pointer<cvec_t> spectrum,
  ) {
    return _aubio_fft_get_norm(
      compspec,
      spectrum,
    );
  }

  late final _aubio_fft_get_norm_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_fft_get_norm>>('aubio_fft_get_norm');
  late final _dart_aubio_fft_get_norm _aubio_fft_get_norm =
      _aubio_fft_get_norm_ptr.asFunction<_dart_aubio_fft_get_norm>();

  /// compute real part from norm/phas components
  ///
  /// \param spectrum norm/phas input array
  /// \param compspec real/imag output fft array
  void aubio_fft_get_real(
    ffi.Pointer<cvec_t> spectrum,
    ffi.Pointer<fvec_t> compspec,
  ) {
    return _aubio_fft_get_real(
      spectrum,
      compspec,
    );
  }

  late final _aubio_fft_get_real_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_fft_get_real>>('aubio_fft_get_real');
  late final _dart_aubio_fft_get_real _aubio_fft_get_real =
      _aubio_fft_get_real_ptr.asFunction<_dart_aubio_fft_get_real>();

  /// create new DCT computation object
  ///
  /// \param size length of the DCT
  ffi.Pointer<_aubio_dct_t> new_aubio_dct(
    int size,
  ) {
    return _new_aubio_dct(
      size,
    );
  }

  late final _new_aubio_dct_ptr =
      _lookup<ffi.NativeFunction<_c_new_aubio_dct>>('new_aubio_dct');
  late final _dart_new_aubio_dct _new_aubio_dct =
      _new_aubio_dct_ptr.asFunction<_dart_new_aubio_dct>();

  /// compute forward DCT
  ///
  /// \param s dct object as returned by new_aubio_dct
  /// \param input input signal
  /// \param dct_output transformed input array
  void aubio_dct_do(
    ffi.Pointer<_aubio_dct_t> s,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> dct_output,
  ) {
    return _aubio_dct_do(
      s,
      input,
      dct_output,
    );
  }

  late final _aubio_dct_do_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_dct_do>>('aubio_dct_do');
  late final _dart_aubio_dct_do _aubio_dct_do =
      _aubio_dct_do_ptr.asFunction<_dart_aubio_dct_do>();

  /// compute backward DCT
  ///
  /// \param s dct object as returned by new_aubio_dct
  /// \param input input signal
  /// \param idct_output transformed input array
  void aubio_dct_rdo(
    ffi.Pointer<_aubio_dct_t> s,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> idct_output,
  ) {
    return _aubio_dct_rdo(
      s,
      input,
      idct_output,
    );
  }

  late final _aubio_dct_rdo_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_dct_rdo>>('aubio_dct_rdo');
  late final _dart_aubio_dct_rdo _aubio_dct_rdo =
      _aubio_dct_rdo_ptr.asFunction<_dart_aubio_dct_rdo>();

  /// delete DCT object
  ///
  /// \param s dct object as returned by new_aubio_dct
  void del_aubio_dct(
    ffi.Pointer<_aubio_dct_t> s,
  ) {
    return _del_aubio_dct(
      s,
    );
  }

  late final _del_aubio_dct_ptr =
      _lookup<ffi.NativeFunction<_c_del_aubio_dct>>('del_aubio_dct');
  late final _dart_del_aubio_dct _del_aubio_dct =
      _del_aubio_dct_ptr.asFunction<_dart_del_aubio_dct>();

  /// create phase vocoder object
  ///
  /// \param win_s size of analysis buffer (and length the FFT transform)
  /// \param hop_s step size between two consecutive analysis
  ffi.Pointer<_aubio_pvoc_t> new_aubio_pvoc(
    int win_s,
    int hop_s,
  ) {
    return _new_aubio_pvoc(
      win_s,
      hop_s,
    );
  }

  late final _new_aubio_pvoc_ptr =
      _lookup<ffi.NativeFunction<_c_new_aubio_pvoc>>('new_aubio_pvoc');
  late final _dart_new_aubio_pvoc _new_aubio_pvoc =
      _new_aubio_pvoc_ptr.asFunction<_dart_new_aubio_pvoc>();

  /// delete phase vocoder object
  ///
  /// \param pv phase vocoder object as returned by new_aubio_pvoc
  void del_aubio_pvoc(
    ffi.Pointer<_aubio_pvoc_t> pv,
  ) {
    return _del_aubio_pvoc(
      pv,
    );
  }

  late final _del_aubio_pvoc_ptr =
      _lookup<ffi.NativeFunction<_c_del_aubio_pvoc>>('del_aubio_pvoc');
  late final _dart_del_aubio_pvoc _del_aubio_pvoc =
      _del_aubio_pvoc_ptr.asFunction<_dart_del_aubio_pvoc>();

  /// compute spectral frame
  ///
  /// This function accepts an input vector of size [hop_s]. The
  /// analysis buffer is rotated and filled with the new data. After windowing of
  /// this signal window, the Fourier transform is computed and returned in
  /// fftgrain as two vectors, magnitude and phase.
  ///
  /// \param pv phase vocoder object as returned by new_aubio_pvoc
  /// \param in new input signal (hop_s long)
  /// \param fftgrain output spectral frame
  void aubio_pvoc_do(
    ffi.Pointer<_aubio_pvoc_t> pv,
    ffi.Pointer<fvec_t> in_1,
    ffi.Pointer<cvec_t> fftgrain,
  ) {
    return _aubio_pvoc_do(
      pv,
      in_1,
      fftgrain,
    );
  }

  late final _aubio_pvoc_do_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_pvoc_do>>('aubio_pvoc_do');
  late final _dart_aubio_pvoc_do _aubio_pvoc_do =
      _aubio_pvoc_do_ptr.asFunction<_dart_aubio_pvoc_do>();

  /// compute signal from spectral frame
  ///
  /// This function takes an input spectral frame fftgrain of size
  /// [buf_s] and computes its inverse Fourier transform. Overlap-add
  /// synthesis is then computed using the previously synthetised frames, and the
  /// output stored in out.
  ///
  /// \param pv phase vocoder object as returned by new_aubio_pvoc
  /// \param fftgrain input spectral frame
  /// \param out output signal (hop_s long)
  void aubio_pvoc_rdo(
    ffi.Pointer<_aubio_pvoc_t> pv,
    ffi.Pointer<cvec_t> fftgrain,
    ffi.Pointer<fvec_t> out,
  ) {
    return _aubio_pvoc_rdo(
      pv,
      fftgrain,
      out,
    );
  }

  late final _aubio_pvoc_rdo_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_pvoc_rdo>>('aubio_pvoc_rdo');
  late final _dart_aubio_pvoc_rdo _aubio_pvoc_rdo =
      _aubio_pvoc_rdo_ptr.asFunction<_dart_aubio_pvoc_rdo>();

  /// get window size
  ///
  /// \param pv phase vocoder to get the window size from
  int aubio_pvoc_get_win(
    ffi.Pointer<_aubio_pvoc_t> pv,
  ) {
    return _aubio_pvoc_get_win(
      pv,
    );
  }

  late final _aubio_pvoc_get_win_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_pvoc_get_win>>('aubio_pvoc_get_win');
  late final _dart_aubio_pvoc_get_win _aubio_pvoc_get_win =
      _aubio_pvoc_get_win_ptr.asFunction<_dart_aubio_pvoc_get_win>();

  /// get hop size
  ///
  /// \param pv phase vocoder to get the hop size from
  int aubio_pvoc_get_hop(
    ffi.Pointer<_aubio_pvoc_t> pv,
  ) {
    return _aubio_pvoc_get_hop(
      pv,
    );
  }

  late final _aubio_pvoc_get_hop_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_pvoc_get_hop>>('aubio_pvoc_get_hop');
  late final _dart_aubio_pvoc_get_hop _aubio_pvoc_get_hop =
      _aubio_pvoc_get_hop_ptr.asFunction<_dart_aubio_pvoc_get_hop>();

  /// set window type
  ///
  /// \param pv phase vocoder to set the window type
  /// \param window_type a string representing a window
  ///
  /// \return 0 if successful, non-zero otherwise
  int aubio_pvoc_set_window(
    ffi.Pointer<_aubio_pvoc_t> pv,
    ffi.Pointer<ffi.Int8> window_type,
  ) {
    return _aubio_pvoc_set_window(
      pv,
      window_type,
    );
  }

  late final _aubio_pvoc_set_window_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_pvoc_set_window>>(
          'aubio_pvoc_set_window');
  late final _dart_aubio_pvoc_set_window _aubio_pvoc_set_window =
      _aubio_pvoc_set_window_ptr.asFunction<_dart_aubio_pvoc_set_window>();

  /// create filterbank object
  ///
  /// \param n_filters number of filters to create
  /// \param win_s size of analysis buffer (and length the FFT transform)
  ffi.Pointer<_aubio_filterbank_t> new_aubio_filterbank(
    int n_filters,
    int win_s,
  ) {
    return _new_aubio_filterbank(
      n_filters,
      win_s,
    );
  }

  late final _new_aubio_filterbank_ptr =
      _lookup<ffi.NativeFunction<_c_new_aubio_filterbank>>(
          'new_aubio_filterbank');
  late final _dart_new_aubio_filterbank _new_aubio_filterbank =
      _new_aubio_filterbank_ptr.asFunction<_dart_new_aubio_filterbank>();

  /// destroy filterbank object
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  void del_aubio_filterbank(
    ffi.Pointer<_aubio_filterbank_t> f,
  ) {
    return _del_aubio_filterbank(
      f,
    );
  }

  late final _del_aubio_filterbank_ptr =
      _lookup<ffi.NativeFunction<_c_del_aubio_filterbank>>(
          'del_aubio_filterbank');
  late final _dart_del_aubio_filterbank _del_aubio_filterbank =
      _del_aubio_filterbank_ptr.asFunction<_dart_del_aubio_filterbank>();

  /// compute filterbank
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  /// \param in input spectrum containing an input spectrum of length `win_s`
  /// \param out output vector containing the energy found in each band, `nfilt` output values
  void aubio_filterbank_do(
    ffi.Pointer<_aubio_filterbank_t> f,
    ffi.Pointer<cvec_t> in_1,
    ffi.Pointer<fvec_t> out,
  ) {
    return _aubio_filterbank_do(
      f,
      in_1,
      out,
    );
  }

  late final _aubio_filterbank_do_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_filterbank_do>>(
          'aubio_filterbank_do');
  late final _dart_aubio_filterbank_do _aubio_filterbank_do =
      _aubio_filterbank_do_ptr.asFunction<_dart_aubio_filterbank_do>();

  /// return a pointer to the matrix object containing all filter coefficients
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  ffi.Pointer<fmat_t> aubio_filterbank_get_coeffs(
    ffi.Pointer<_aubio_filterbank_t> f,
  ) {
    return _aubio_filterbank_get_coeffs(
      f,
    );
  }

  late final _aubio_filterbank_get_coeffs_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_filterbank_get_coeffs>>(
          'aubio_filterbank_get_coeffs');
  late final _dart_aubio_filterbank_get_coeffs _aubio_filterbank_get_coeffs =
      _aubio_filterbank_get_coeffs_ptr
          .asFunction<_dart_aubio_filterbank_get_coeffs>();

  /// copy filter coefficients to the filterbank
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  /// \param filters filter bank coefficients to copy from
  int aubio_filterbank_set_coeffs(
    ffi.Pointer<_aubio_filterbank_t> f,
    ffi.Pointer<fmat_t> filters,
  ) {
    return _aubio_filterbank_set_coeffs(
      f,
      filters,
    );
  }

  late final _aubio_filterbank_set_coeffs_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_filterbank_set_coeffs>>(
          'aubio_filterbank_set_coeffs');
  late final _dart_aubio_filterbank_set_coeffs _aubio_filterbank_set_coeffs =
      _aubio_filterbank_set_coeffs_ptr
          .asFunction<_dart_aubio_filterbank_set_coeffs>();

  /// set norm parameter
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  /// \param norm `1` to norm the filters, `0` otherwise.
  ///
  /// If set to `0`, the filters will not be normalized. If set to `1`,
  /// each filter will be normalized to one. Defaults to `1`.
  ///
  /// This function should be called *before* setting the filters with one of
  /// aubio_filterbank_set_triangle_bands(), aubio_filterbank_set_mel_coeffs(),
  /// aubio_filterbank_set_mel_coeffs_htk(), or
  /// aubio_filterbank_set_mel_coeffs_slaney().
  int aubio_filterbank_set_norm(
    ffi.Pointer<_aubio_filterbank_t> f,
    double norm,
  ) {
    return _aubio_filterbank_set_norm(
      f,
      norm,
    );
  }

  late final _aubio_filterbank_set_norm_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_filterbank_set_norm>>(
          'aubio_filterbank_set_norm');
  late final _dart_aubio_filterbank_set_norm _aubio_filterbank_set_norm =
      _aubio_filterbank_set_norm_ptr
          .asFunction<_dart_aubio_filterbank_set_norm>();

  /// get norm parameter
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  /// \returns `1` if norm is set, `0` otherwise. Defaults to `1`.
  double aubio_filterbank_get_norm(
    ffi.Pointer<_aubio_filterbank_t> f,
  ) {
    return _aubio_filterbank_get_norm(
      f,
    );
  }

  late final _aubio_filterbank_get_norm_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_filterbank_get_norm>>(
          'aubio_filterbank_get_norm');
  late final _dart_aubio_filterbank_get_norm _aubio_filterbank_get_norm =
      _aubio_filterbank_get_norm_ptr
          .asFunction<_dart_aubio_filterbank_get_norm>();

  /// set power parameter
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  /// \param power Raise norm of the input spectrum norm to this power before
  /// computing filterbank.  Defaults to `1`.
  int aubio_filterbank_set_power(
    ffi.Pointer<_aubio_filterbank_t> f,
    double power,
  ) {
    return _aubio_filterbank_set_power(
      f,
      power,
    );
  }

  late final _aubio_filterbank_set_power_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_filterbank_set_power>>(
          'aubio_filterbank_set_power');
  late final _dart_aubio_filterbank_set_power _aubio_filterbank_set_power =
      _aubio_filterbank_set_power_ptr
          .asFunction<_dart_aubio_filterbank_set_power>();

  /// get power parameter
  ///
  /// \param f filterbank object, as returned by new_aubio_filterbank()
  /// \return current power parameter. Defaults to `1`.
  double aubio_filterbank_get_power(
    ffi.Pointer<_aubio_filterbank_t> f,
  ) {
    return _aubio_filterbank_get_power(
      f,
    );
  }

  late final _aubio_filterbank_get_power_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_filterbank_get_power>>(
          'aubio_filterbank_get_power');
  late final _dart_aubio_filterbank_get_power _aubio_filterbank_get_power =
      _aubio_filterbank_get_power_ptr
          .asFunction<_dart_aubio_filterbank_get_power>();

  /// filterbank initialization with triangular and overlapping bands
  ///
  /// \param fb filterbank object
  /// \param freqs arbitrary array of boundary frequencies
  /// \param samplerate audio sampling rate
  ///
  /// This function computes the coefficients of the filterbank based on the
  /// boundaries found in freqs, in Hz, and using triangular overlapping bands.
  int aubio_filterbank_set_triangle_bands(
    ffi.Pointer<_aubio_filterbank_t> fb,
    ffi.Pointer<fvec_t> freqs,
    double samplerate,
  ) {
    return _aubio_filterbank_set_triangle_bands(
      fb,
      freqs,
      samplerate,
    );
  }

  late final _aubio_filterbank_set_triangle_bands_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_filterbank_set_triangle_bands>>(
          'aubio_filterbank_set_triangle_bands');
  late final _dart_aubio_filterbank_set_triangle_bands
      _aubio_filterbank_set_triangle_bands =
      _aubio_filterbank_set_triangle_bands_ptr
          .asFunction<_dart_aubio_filterbank_set_triangle_bands>();

  /// filterbank initialization for Mel filters using Slaney's coefficients
  ///
  /// \param fb filterbank object
  /// \param samplerate audio sampling rate, in Hz
  ///
  /// The filter coefficients are built to match exactly Malcolm Slaney's Auditory
  /// Toolbox implementation (see file mfcc.m). The number of filters should be 40.
  ///
  /// References
  /// ----------
  ///
  /// Malcolm Slaney, *Auditory Toolbox Version 2, Technical Report #1998-010*
  /// https://engineering.purdue.edu/~malcolm/interval/1998-010/
  int aubio_filterbank_set_mel_coeffs_slaney(
    ffi.Pointer<_aubio_filterbank_t> fb,
    double samplerate,
  ) {
    return _aubio_filterbank_set_mel_coeffs_slaney(
      fb,
      samplerate,
    );
  }

  late final _aubio_filterbank_set_mel_coeffs_slaney_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_filterbank_set_mel_coeffs_slaney>>(
          'aubio_filterbank_set_mel_coeffs_slaney');
  late final _dart_aubio_filterbank_set_mel_coeffs_slaney
      _aubio_filterbank_set_mel_coeffs_slaney =
      _aubio_filterbank_set_mel_coeffs_slaney_ptr
          .asFunction<_dart_aubio_filterbank_set_mel_coeffs_slaney>();

  /// Mel filterbank initialization
  ///
  /// \param fb filterbank object
  /// \param samplerate audio sampling rate
  /// \param fmin start frequency, in Hz
  /// \param fmax end frequency, in Hz
  ///
  /// The filterbank will be initialized with bands linearly spaced in the mel
  /// scale, from `fmin` to `fmax`.
  ///
  /// References
  /// ----------
  ///
  /// Malcolm Slaney, *Auditory Toolbox Version 2, Technical Report #1998-010*
  /// https://engineering.purdue.edu/~malcolm/interval/1998-010/
  int aubio_filterbank_set_mel_coeffs(
    ffi.Pointer<_aubio_filterbank_t> fb,
    double samplerate,
    double fmin,
    double fmax,
  ) {
    return _aubio_filterbank_set_mel_coeffs(
      fb,
      samplerate,
      fmin,
      fmax,
    );
  }

  late final _aubio_filterbank_set_mel_coeffs_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_filterbank_set_mel_coeffs>>(
          'aubio_filterbank_set_mel_coeffs');
  late final _dart_aubio_filterbank_set_mel_coeffs
      _aubio_filterbank_set_mel_coeffs = _aubio_filterbank_set_mel_coeffs_ptr
          .asFunction<_dart_aubio_filterbank_set_mel_coeffs>();

  /// Mel filterbank initialization
  ///
  /// \param fb filterbank object
  /// \param samplerate audio sampling rate
  /// \param fmin start frequency, in Hz
  /// \param fmax end frequency, in Hz
  ///
  /// The bank of filters will be initalized to to cover linearly spaced bands in
  /// the Htk mel scale, from `fmin` to `fmax`.
  ///
  /// References
  /// ----------
  ///
  /// Douglas O'Shaughnessy (1987). *Speech communication: human and machine*.
  /// Addison-Wesley. p. 150. ISBN 978-0-201-16520-3.
  ///
  /// HTK Speech Recognition Toolkit: http://htk.eng.cam.ac.uk/
  int aubio_filterbank_set_mel_coeffs_htk(
    ffi.Pointer<_aubio_filterbank_t> fb,
    double samplerate,
    double fmin,
    double fmax,
  ) {
    return _aubio_filterbank_set_mel_coeffs_htk(
      fb,
      samplerate,
      fmin,
      fmax,
    );
  }

  late final _aubio_filterbank_set_mel_coeffs_htk_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_filterbank_set_mel_coeffs_htk>>(
          'aubio_filterbank_set_mel_coeffs_htk');
  late final _dart_aubio_filterbank_set_mel_coeffs_htk
      _aubio_filterbank_set_mel_coeffs_htk =
      _aubio_filterbank_set_mel_coeffs_htk_ptr
          .asFunction<_dart_aubio_filterbank_set_mel_coeffs_htk>();

  /// create mfcc object
  ///
  /// \param buf_size size of analysis buffer (and length the FFT transform)
  /// \param samplerate audio sampling rate
  /// \param n_coeffs number of desired coefficients
  /// \param n_filters number of desired filters
  ffi.Pointer<_aubio_mfcc_t> new_aubio_mfcc(
    int buf_size,
    int n_filters,
    int n_coeffs,
    int samplerate,
  ) {
    return _new_aubio_mfcc(
      buf_size,
      n_filters,
      n_coeffs,
      samplerate,
    );
  }

  late final _new_aubio_mfcc_ptr =
      _lookup<ffi.NativeFunction<_c_new_aubio_mfcc>>('new_aubio_mfcc');
  late final _dart_new_aubio_mfcc _new_aubio_mfcc =
      _new_aubio_mfcc_ptr.asFunction<_dart_new_aubio_mfcc>();

  /// delete mfcc object
  ///
  /// \param mf mfcc object as returned by new_aubio_mfcc
  void del_aubio_mfcc(
    ffi.Pointer<_aubio_mfcc_t> mf,
  ) {
    return _del_aubio_mfcc(
      mf,
    );
  }

  late final _del_aubio_mfcc_ptr =
      _lookup<ffi.NativeFunction<_c_del_aubio_mfcc>>('del_aubio_mfcc');
  late final _dart_del_aubio_mfcc _del_aubio_mfcc =
      _del_aubio_mfcc_ptr.asFunction<_dart_del_aubio_mfcc>();

  /// mfcc object processing
  ///
  /// \param mf mfcc object as returned by new_aubio_mfcc
  /// \param in input spectrum (buf_size long)
  /// \param out output mel coefficients buffer (n_coeffs long)
  void aubio_mfcc_do(
    ffi.Pointer<_aubio_mfcc_t> mf,
    ffi.Pointer<cvec_t> in_1,
    ffi.Pointer<fvec_t> out,
  ) {
    return _aubio_mfcc_do(
      mf,
      in_1,
      out,
    );
  }

  late final _aubio_mfcc_do_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_mfcc_do>>('aubio_mfcc_do');
  late final _dart_aubio_mfcc_do _aubio_mfcc_do =
      _aubio_mfcc_do_ptr.asFunction<_dart_aubio_mfcc_do>();

  /// set power parameter
  ///
  /// \param mf mfcc object, as returned by new_aubio_mfcc()
  /// \param power Raise norm of the input spectrum norm to this power before
  /// computing filterbank.  Defaults to `1`.
  ///
  /// See aubio_filterbank_set_power().
  int aubio_mfcc_set_power(
    ffi.Pointer<_aubio_mfcc_t> mf,
    double power,
  ) {
    return _aubio_mfcc_set_power(
      mf,
      power,
    );
  }

  late final _aubio_mfcc_set_power_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_mfcc_set_power>>(
          'aubio_mfcc_set_power');
  late final _dart_aubio_mfcc_set_power _aubio_mfcc_set_power =
      _aubio_mfcc_set_power_ptr.asFunction<_dart_aubio_mfcc_set_power>();

  /// get power parameter
  ///
  /// \param mf mfcc object, as returned by new_aubio_mfcc()
  /// \return current power parameter. Defaults to `1`.
  ///
  /// See aubio_filterbank_get_power().
  double aubio_mfcc_get_power(
    ffi.Pointer<_aubio_mfcc_t> mf,
  ) {
    return _aubio_mfcc_get_power(
      mf,
    );
  }

  late final _aubio_mfcc_get_power_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_mfcc_get_power>>(
          'aubio_mfcc_get_power');
  late final _dart_aubio_mfcc_get_power _aubio_mfcc_get_power =
      _aubio_mfcc_get_power_ptr.asFunction<_dart_aubio_mfcc_get_power>();

  /// set scaling parameter
  ///
  /// \param mf mfcc object, as returned by new_aubio_mfcc()
  /// \param scale Scaling value to apply.
  ///
  /// Scales the output of the filterbank after taking its logarithm and before
  /// computing the DCT. Defaults to `1`.
  int aubio_mfcc_set_scale(
    ffi.Pointer<_aubio_mfcc_t> mf,
    double scale,
  ) {
    return _aubio_mfcc_set_scale(
      mf,
      scale,
    );
  }

  late final _aubio_mfcc_set_scale_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_mfcc_set_scale>>(
          'aubio_mfcc_set_scale');
  late final _dart_aubio_mfcc_set_scale _aubio_mfcc_set_scale =
      _aubio_mfcc_set_scale_ptr.asFunction<_dart_aubio_mfcc_set_scale>();

  /// get scaling parameter
  ///
  /// \param mf mfcc object, as returned by new_aubio_mfcc()
  /// \return current scaling parameter. Defaults to `1`.
  double aubio_mfcc_get_scale(
    ffi.Pointer<_aubio_mfcc_t> mf,
  ) {
    return _aubio_mfcc_get_scale(
      mf,
    );
  }

  late final _aubio_mfcc_get_scale_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_mfcc_get_scale>>(
          'aubio_mfcc_get_scale');
  late final _dart_aubio_mfcc_get_scale _aubio_mfcc_get_scale =
      _aubio_mfcc_get_scale_ptr.asFunction<_dart_aubio_mfcc_get_scale>();

  /// Mel filterbank initialization
  ///
  /// \param mf mfcc object
  /// \param fmin start frequency, in Hz
  /// \param fmax end frequency, in Hz
  ///
  /// The filterbank will be initialized with bands linearly spaced in the mel
  /// scale, from `fmin` to `fmax`.
  ///
  /// See also
  /// --------
  ///
  /// aubio_filterbank_set_mel_coeffs()
  int aubio_mfcc_set_mel_coeffs(
    ffi.Pointer<_aubio_mfcc_t> mf,
    double fmin,
    double fmax,
  ) {
    return _aubio_mfcc_set_mel_coeffs(
      mf,
      fmin,
      fmax,
    );
  }

  late final _aubio_mfcc_set_mel_coeffs_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_mfcc_set_mel_coeffs>>(
          'aubio_mfcc_set_mel_coeffs');
  late final _dart_aubio_mfcc_set_mel_coeffs _aubio_mfcc_set_mel_coeffs =
      _aubio_mfcc_set_mel_coeffs_ptr
          .asFunction<_dart_aubio_mfcc_set_mel_coeffs>();

  /// Mel filterbank initialization
  ///
  /// \param mf mfcc object
  /// \param fmin start frequency, in Hz
  /// \param fmax end frequency, in Hz
  ///
  /// The bank of filters will be initalized to to cover linearly spaced bands in
  /// the Htk mel scale, from `fmin` to `fmax`.
  ///
  /// See also
  /// --------
  ///
  /// aubio_filterbank_set_mel_coeffs_htk()
  int aubio_mfcc_set_mel_coeffs_htk(
    ffi.Pointer<_aubio_mfcc_t> mf,
    double fmin,
    double fmax,
  ) {
    return _aubio_mfcc_set_mel_coeffs_htk(
      mf,
      fmin,
      fmax,
    );
  }

  late final _aubio_mfcc_set_mel_coeffs_htk_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_mfcc_set_mel_coeffs_htk>>(
          'aubio_mfcc_set_mel_coeffs_htk');
  late final _dart_aubio_mfcc_set_mel_coeffs_htk
      _aubio_mfcc_set_mel_coeffs_htk = _aubio_mfcc_set_mel_coeffs_htk_ptr
          .asFunction<_dart_aubio_mfcc_set_mel_coeffs_htk>();

  /// Mel filterbank initialization (Auditory Toolbox's parameters)
  ///
  /// \param mf mfcc object
  ///
  /// The filter coefficients are built to match exactly Malcolm Slaney's Auditory
  /// Toolbox implementation. The number of filters should be 40.
  ///
  /// This is the default filterbank when `mf` was created with `n_filters = 40`.
  ///
  /// See also
  /// --------
  ///
  /// aubio_filterbank_set_mel_coeffs_slaney()
  int aubio_mfcc_set_mel_coeffs_slaney(
    ffi.Pointer<_aubio_mfcc_t> mf,
  ) {
    return _aubio_mfcc_set_mel_coeffs_slaney(
      mf,
    );
  }

  late final _aubio_mfcc_set_mel_coeffs_slaney_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_mfcc_set_mel_coeffs_slaney>>(
          'aubio_mfcc_set_mel_coeffs_slaney');
  late final _dart_aubio_mfcc_set_mel_coeffs_slaney
      _aubio_mfcc_set_mel_coeffs_slaney = _aubio_mfcc_set_mel_coeffs_slaney_ptr
          .asFunction<_dart_aubio_mfcc_set_mel_coeffs_slaney>();

  /// execute spectral description function on a spectral frame
  ///
  /// Generic function to compute spectral description.
  ///
  /// \param o spectral description object as returned by new_aubio_specdesc()
  /// \param fftgrain input signal spectrum as computed by aubio_pvoc_do
  /// \param desc output vector (one sample long, to send to the peak picking)
  void aubio_specdesc_do(
    ffi.Pointer<_aubio_specdesc_t> o,
    ffi.Pointer<cvec_t> fftgrain,
    ffi.Pointer<fvec_t> desc,
  ) {
    return _aubio_specdesc_do(
      o,
      fftgrain,
      desc,
    );
  }

  late final _aubio_specdesc_do_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_specdesc_do>>('aubio_specdesc_do');
  late final _dart_aubio_specdesc_do _aubio_specdesc_do =
      _aubio_specdesc_do_ptr.asFunction<_dart_aubio_specdesc_do>();

  /// creation of a spectral description object
  ///
  /// \param method spectral description method
  /// \param buf_size length of the input spectrum frame
  ///
  /// The parameter \p method is a string that can be any of:
  ///
  /// - onset novelty functions: `complex`, `energy`, `hfc`, `kl`, `mkl`,
  /// `phase`, `specdiff`, `specflux`, `wphase`,
  ///
  /// - spectral descriptors: `centroid`, `decrease`, `kurtosis`, `rolloff`,
  /// `skewness`, `slope`, `spread`.
  ffi.Pointer<_aubio_specdesc_t> new_aubio_specdesc(
    ffi.Pointer<ffi.Int8> method,
    int buf_size,
  ) {
    return _new_aubio_specdesc(
      method,
      buf_size,
    );
  }

  late final _new_aubio_specdesc_ptr =
      _lookup<ffi.NativeFunction<_c_new_aubio_specdesc>>('new_aubio_specdesc');
  late final _dart_new_aubio_specdesc _new_aubio_specdesc =
      _new_aubio_specdesc_ptr.asFunction<_dart_new_aubio_specdesc>();

  /// deletion of a spectral descriptor
  ///
  /// \param o spectral descriptor object as returned by new_aubio_specdesc()
  void del_aubio_specdesc(
    ffi.Pointer<_aubio_specdesc_t> o,
  ) {
    return _del_aubio_specdesc(
      o,
    );
  }

  late final _del_aubio_specdesc_ptr =
      _lookup<ffi.NativeFunction<_c_del_aubio_specdesc>>('del_aubio_specdesc');
  late final _dart_del_aubio_specdesc _del_aubio_specdesc =
      _del_aubio_specdesc_ptr.asFunction<_dart_del_aubio_specdesc>();

  /// execute spectral adaptive whitening, in-place
  ///
  /// \param o spectral whitening object as returned by new_aubio_spectral_whitening()
  /// \param fftgrain input signal spectrum as computed by aubio_pvoc_do() or aubio_fft_do()
  void aubio_spectral_whitening_do(
    ffi.Pointer<_aubio_spectral_whitening_t> o,
    ffi.Pointer<cvec_t> fftgrain,
  ) {
    return _aubio_spectral_whitening_do(
      o,
      fftgrain,
    );
  }

  late final _aubio_spectral_whitening_do_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_spectral_whitening_do>>(
          'aubio_spectral_whitening_do');
  late final _dart_aubio_spectral_whitening_do _aubio_spectral_whitening_do =
      _aubio_spectral_whitening_do_ptr
          .asFunction<_dart_aubio_spectral_whitening_do>();

  /// creation of a spectral whitening object
  ///
  /// \param buf_size window size of input grains
  /// \param hop_size number of samples between two consecutive input grains
  /// \param samplerate sampling rate of the input signal
  ffi.Pointer<_aubio_spectral_whitening_t> new_aubio_spectral_whitening(
    int buf_size,
    int hop_size,
    int samplerate,
  ) {
    return _new_aubio_spectral_whitening(
      buf_size,
      hop_size,
      samplerate,
    );
  }

  late final _new_aubio_spectral_whitening_ptr =
      _lookup<ffi.NativeFunction<_c_new_aubio_spectral_whitening>>(
          'new_aubio_spectral_whitening');
  late final _dart_new_aubio_spectral_whitening _new_aubio_spectral_whitening =
      _new_aubio_spectral_whitening_ptr
          .asFunction<_dart_new_aubio_spectral_whitening>();

  /// reset spectral whitening object
  ///
  /// \param o spectral whitening object as returned by new_aubio_spectral_whitening()
  void aubio_spectral_whitening_reset(
    ffi.Pointer<_aubio_spectral_whitening_t> o,
  ) {
    return _aubio_spectral_whitening_reset(
      o,
    );
  }

  late final _aubio_spectral_whitening_reset_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_spectral_whitening_reset>>(
          'aubio_spectral_whitening_reset');
  late final _dart_aubio_spectral_whitening_reset
      _aubio_spectral_whitening_reset = _aubio_spectral_whitening_reset_ptr
          .asFunction<_dart_aubio_spectral_whitening_reset>();

  /// set relaxation time for spectral whitening
  ///
  /// \param o spectral whitening object as returned by new_aubio_spectral_whitening()
  /// \param relax_time relaxation time in seconds between 20 and 500, defaults 250
  int aubio_spectral_whitening_set_relax_time(
    ffi.Pointer<_aubio_spectral_whitening_t> o,
    double relax_time,
  ) {
    return _aubio_spectral_whitening_set_relax_time(
      o,
      relax_time,
    );
  }

  late final _aubio_spectral_whitening_set_relax_time_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_spectral_whitening_set_relax_time>>(
          'aubio_spectral_whitening_set_relax_time');
  late final _dart_aubio_spectral_whitening_set_relax_time
      _aubio_spectral_whitening_set_relax_time =
      _aubio_spectral_whitening_set_relax_time_ptr
          .asFunction<_dart_aubio_spectral_whitening_set_relax_time>();

  /// get relaxation time of spectral whitening
  ///
  /// \param o spectral whitening object as returned by new_aubio_spectral_whitening()
  /// \return relaxation time in seconds
  double aubio_spectral_whitening_get_relax_time(
    ffi.Pointer<_aubio_spectral_whitening_t> o,
  ) {
    return _aubio_spectral_whitening_get_relax_time(
      o,
    );
  }

  late final _aubio_spectral_whitening_get_relax_time_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_spectral_whitening_get_relax_time>>(
          'aubio_spectral_whitening_get_relax_time');
  late final _dart_aubio_spectral_whitening_get_relax_time
      _aubio_spectral_whitening_get_relax_time =
      _aubio_spectral_whitening_get_relax_time_ptr
          .asFunction<_dart_aubio_spectral_whitening_get_relax_time>();

  /// set floor for spectral whitening
  ///
  /// \param o spectral whitening object as returned by new_aubio_spectral_whitening()
  /// \param floor value (typically between 1.e-6 and .2, defaults to 1.e-4)
  int aubio_spectral_whitening_set_floor(
    ffi.Pointer<_aubio_spectral_whitening_t> o,
    double floor,
  ) {
    return _aubio_spectral_whitening_set_floor(
      o,
      floor,
    );
  }

  late final _aubio_spectral_whitening_set_floor_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_spectral_whitening_set_floor>>(
          'aubio_spectral_whitening_set_floor');
  late final _dart_aubio_spectral_whitening_set_floor
      _aubio_spectral_whitening_set_floor =
      _aubio_spectral_whitening_set_floor_ptr
          .asFunction<_dart_aubio_spectral_whitening_set_floor>();

  /// get floor of spectral whitening
  ///
  /// \param o spectral whitening object as returned by new_aubio_spectral_whitening()
  /// \return floor value
  double aubio_spectral_whitening_get_floor(
    ffi.Pointer<_aubio_spectral_whitening_t> o,
  ) {
    return _aubio_spectral_whitening_get_floor(
      o,
    );
  }

  late final _aubio_spectral_whitening_get_floor_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_spectral_whitening_get_floor>>(
          'aubio_spectral_whitening_get_floor');
  late final _dart_aubio_spectral_whitening_get_floor
      _aubio_spectral_whitening_get_floor =
      _aubio_spectral_whitening_get_floor_ptr
          .asFunction<_dart_aubio_spectral_whitening_get_floor>();

  /// deletion of a spectral whitening
  ///
  /// \param o spectral whitening object as returned by new_aubio_spectral_whitening()
  void del_aubio_spectral_whitening(
    ffi.Pointer<_aubio_spectral_whitening_t> o,
  ) {
    return _del_aubio_spectral_whitening(
      o,
    );
  }

  late final _del_aubio_spectral_whitening_ptr =
      _lookup<ffi.NativeFunction<_c_del_aubio_spectral_whitening>>(
          'del_aubio_spectral_whitening');
  late final _dart_del_aubio_spectral_whitening _del_aubio_spectral_whitening =
      _del_aubio_spectral_whitening_ptr
          .asFunction<_dart_del_aubio_spectral_whitening>();

  /// create tss object
  ///
  /// \param buf_size buffer size
  /// \param hop_size step size
  ffi.Pointer<_aubio_tss_t> new_aubio_tss(
    int buf_size,
    int hop_size,
  ) {
    return _new_aubio_tss(
      buf_size,
      hop_size,
    );
  }

  late final _new_aubio_tss_ptr =
      _lookup<ffi.NativeFunction<_c_new_aubio_tss>>('new_aubio_tss');
  late final _dart_new_aubio_tss _new_aubio_tss =
      _new_aubio_tss_ptr.asFunction<_dart_new_aubio_tss>();

  /// delete tss object
  ///
  /// \param o tss object as returned by new_aubio_tss()
  void del_aubio_tss(
    ffi.Pointer<_aubio_tss_t> o,
  ) {
    return _del_aubio_tss(
      o,
    );
  }

  late final _del_aubio_tss_ptr =
      _lookup<ffi.NativeFunction<_c_del_aubio_tss>>('del_aubio_tss');
  late final _dart_del_aubio_tss _del_aubio_tss =
      _del_aubio_tss_ptr.asFunction<_dart_del_aubio_tss>();

  /// split input into transient and steady states components
  ///
  /// \param o tss object as returned by new_aubio_tss()
  /// \param input input spectral frame
  /// \param trans output transient components
  /// \param stead output steady state components
  void aubio_tss_do(
    ffi.Pointer<_aubio_tss_t> o,
    ffi.Pointer<cvec_t> input,
    ffi.Pointer<cvec_t> trans,
    ffi.Pointer<cvec_t> stead,
  ) {
    return _aubio_tss_do(
      o,
      input,
      trans,
      stead,
    );
  }

  late final _aubio_tss_do_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tss_do>>('aubio_tss_do');
  late final _dart_aubio_tss_do _aubio_tss_do =
      _aubio_tss_do_ptr.asFunction<_dart_aubio_tss_do>();

  /// set transient / steady state separation threshold
  ///
  /// \param o tss object as returned by new_aubio_tss()
  /// \param thrs new threshold value
  int aubio_tss_set_threshold(
    ffi.Pointer<_aubio_tss_t> o,
    double thrs,
  ) {
    return _aubio_tss_set_threshold(
      o,
      thrs,
    );
  }

  late final _aubio_tss_set_threshold_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tss_set_threshold>>(
          'aubio_tss_set_threshold');
  late final _dart_aubio_tss_set_threshold _aubio_tss_set_threshold =
      _aubio_tss_set_threshold_ptr.asFunction<_dart_aubio_tss_set_threshold>();

  /// set parameter a, defaults to 3
  ///
  /// \param o tss object as returned by new_aubio_tss()
  /// \param alpha new value for alpha parameter
  int aubio_tss_set_alpha(
    ffi.Pointer<_aubio_tss_t> o,
    double alpha,
  ) {
    return _aubio_tss_set_alpha(
      o,
      alpha,
    );
  }

  late final _aubio_tss_set_alpha_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tss_set_alpha>>(
          'aubio_tss_set_alpha');
  late final _dart_aubio_tss_set_alpha _aubio_tss_set_alpha =
      _aubio_tss_set_alpha_ptr.asFunction<_dart_aubio_tss_set_alpha>();

  /// set parameter b, defaults to 3
  ///
  /// \param o tss object as returned by new_aubio_tss()
  /// \param beta new value for beta parameter
  int aubio_tss_set_beta(
    ffi.Pointer<_aubio_tss_t> o,
    double beta,
  ) {
    return _aubio_tss_set_beta(
      o,
      beta,
    );
  }

  late final _aubio_tss_set_beta_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tss_set_beta>>('aubio_tss_set_beta');
  late final _dart_aubio_tss_set_beta _aubio_tss_set_beta =
      _aubio_tss_set_beta_ptr.asFunction<_dart_aubio_tss_set_beta>();

  /// execute pitch detection on an input signal frame
  ///
  /// \param o pitch detection object as returned by new_aubio_pitch()
  /// \param in input signal of size [hop_size]
  /// \param out output pitch candidates of size [1]
  void aubio_pitch_do(
    ffi.Pointer<_aubio_pitch_t> o,
    ffi.Pointer<fvec_t> in_1,
    ffi.Pointer<fvec_t> out,
  ) {
    return _aubio_pitch_do(
      o,
      in_1,
      out,
    );
  }

  late final _aubio_pitch_do_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_pitch_do>>('aubio_pitch_do');
  late final _dart_aubio_pitch_do _aubio_pitch_do =
      _aubio_pitch_do_ptr.asFunction<_dart_aubio_pitch_do>();

  /// change yin or yinfft tolerance threshold
  ///
  /// \param o pitch detection object as returned by new_aubio_pitch()
  /// \param tol tolerance default is 0.15 for yin and 0.85 for yinfft
  int aubio_pitch_set_tolerance(
    ffi.Pointer<_aubio_pitch_t> o,
    double tol,
  ) {
    return _aubio_pitch_set_tolerance(
      o,
      tol,
    );
  }

  late final _aubio_pitch_set_tolerance_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_pitch_set_tolerance>>(
          'aubio_pitch_set_tolerance');
  late final _dart_aubio_pitch_set_tolerance _aubio_pitch_set_tolerance =
      _aubio_pitch_set_tolerance_ptr
          .asFunction<_dart_aubio_pitch_set_tolerance>();

  /// get yin or yinfft tolerance threshold
  ///
  /// \param o pitch detection object as returned by new_aubio_pitch()
  /// \return tolerance (default is 0.15 for yin and 0.85 for yinfft)
  double aubio_pitch_get_tolerance(
    ffi.Pointer<_aubio_pitch_t> o,
  ) {
    return _aubio_pitch_get_tolerance(
      o,
    );
  }

  late final _aubio_pitch_get_tolerance_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_pitch_get_tolerance>>(
          'aubio_pitch_get_tolerance');
  late final _dart_aubio_pitch_get_tolerance _aubio_pitch_get_tolerance =
      _aubio_pitch_get_tolerance_ptr
          .asFunction<_dart_aubio_pitch_get_tolerance>();

  /// deletion of the pitch detection object
  ///
  /// \param o pitch detection object as returned by new_aubio_pitch()
  void del_aubio_pitch(
    ffi.Pointer<_aubio_pitch_t> o,
  ) {
    return _del_aubio_pitch(
      o,
    );
  }

  late final _del_aubio_pitch_ptr =
      _lookup<ffi.NativeFunction<_c_del_aubio_pitch>>('del_aubio_pitch');
  late final _dart_del_aubio_pitch _del_aubio_pitch =
      _del_aubio_pitch_ptr.asFunction<_dart_del_aubio_pitch>();

  /// creation of the pitch detection object
  ///
  /// \param method set pitch detection algorithm
  /// \param buf_size size of the input buffer to analyse
  /// \param hop_size step size between two consecutive analysis instant
  /// \param samplerate sampling rate of the signal
  ///
  /// \return newly created ::aubio_pitch_t
  ffi.Pointer<_aubio_pitch_t> new_aubio_pitch(
    ffi.Pointer<ffi.Int8> method,
    int buf_size,
    int hop_size,
    int samplerate,
  ) {
    return _new_aubio_pitch(
      method,
      buf_size,
      hop_size,
      samplerate,
    );
  }

  late final _new_aubio_pitch_ptr =
      _lookup<ffi.NativeFunction<_c_new_aubio_pitch>>('new_aubio_pitch');
  late final _dart_new_aubio_pitch _new_aubio_pitch =
      _new_aubio_pitch_ptr.asFunction<_dart_new_aubio_pitch>();

  /// set the output unit of the pitch detection object
  ///
  /// \param o pitch detection object as returned by new_aubio_pitch()
  /// \param mode set pitch units for output
  ///
  /// mode can be one of "Hz", "midi", "cent", or "bin". Defaults to "Hz".
  ///
  /// \return 0 if successfull, non-zero otherwise
  int aubio_pitch_set_unit(
    ffi.Pointer<_aubio_pitch_t> o,
    ffi.Pointer<ffi.Int8> mode,
  ) {
    return _aubio_pitch_set_unit(
      o,
      mode,
    );
  }

  late final _aubio_pitch_set_unit_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_pitch_set_unit>>(
          'aubio_pitch_set_unit');
  late final _dart_aubio_pitch_set_unit _aubio_pitch_set_unit =
      _aubio_pitch_set_unit_ptr.asFunction<_dart_aubio_pitch_set_unit>();

  /// set the silence threshold of the pitch detection object
  ///
  /// \param o pitch detection object as returned by new_aubio_pitch()
  /// \param silence level threshold under which pitch should be ignored, in dB
  ///
  /// \return 0 if successfull, non-zero otherwise
  int aubio_pitch_set_silence(
    ffi.Pointer<_aubio_pitch_t> o,
    double silence,
  ) {
    return _aubio_pitch_set_silence(
      o,
      silence,
    );
  }

  late final _aubio_pitch_set_silence_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_pitch_set_silence>>(
          'aubio_pitch_set_silence');
  late final _dart_aubio_pitch_set_silence _aubio_pitch_set_silence =
      _aubio_pitch_set_silence_ptr.asFunction<_dart_aubio_pitch_set_silence>();

  /// set the silence threshold of the pitch detection object
  ///
  /// \param o pitch detection object as returned by ::new_aubio_pitch()
  ///
  /// \return level threshold under which pitch should be ignored, in dB
  double aubio_pitch_get_silence(
    ffi.Pointer<_aubio_pitch_t> o,
  ) {
    return _aubio_pitch_get_silence(
      o,
    );
  }

  late final _aubio_pitch_get_silence_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_pitch_get_silence>>(
          'aubio_pitch_get_silence');
  late final _dart_aubio_pitch_get_silence _aubio_pitch_get_silence =
      _aubio_pitch_get_silence_ptr.asFunction<_dart_aubio_pitch_get_silence>();

  /// get the current confidence
  ///
  /// \param o pitch detection object as returned by new_aubio_pitch()
  ///
  /// \return the current confidence of the pitch algorithm
  double aubio_pitch_get_confidence(
    ffi.Pointer<_aubio_pitch_t> o,
  ) {
    return _aubio_pitch_get_confidence(
      o,
    );
  }

  late final _aubio_pitch_get_confidence_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_pitch_get_confidence>>(
          'aubio_pitch_get_confidence');
  late final _dart_aubio_pitch_get_confidence _aubio_pitch_get_confidence =
      _aubio_pitch_get_confidence_ptr
          .asFunction<_dart_aubio_pitch_get_confidence>();

  /// create onset detection object
  ///
  /// \param method onset detection type as specified in specdesc.h
  /// \param buf_size buffer size for phase vocoder
  /// \param hop_size hop size for phase vocoder
  /// \param samplerate sampling rate of the input signal
  ///
  /// \return newly created ::aubio_onset_t
  ffi.Pointer<_aubio_onset_t> new_aubio_onset(
    ffi.Pointer<ffi.Int8> method,
    int buf_size,
    int hop_size,
    int samplerate,
  ) {
    return _new_aubio_onset(
      method,
      buf_size,
      hop_size,
      samplerate,
    );
  }

  late final _new_aubio_onset_ptr =
      _lookup<ffi.NativeFunction<_c_new_aubio_onset>>('new_aubio_onset');
  late final _dart_new_aubio_onset _new_aubio_onset =
      _new_aubio_onset_ptr.asFunction<_dart_new_aubio_onset>();

  /// execute onset detection
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param input new audio vector of length hop_size
  /// \param onset output vector of length 1, containing 0 if no onset was found,
  /// and a value equal or greater than 1 otherwise
  ///
  /// When no onset was detected, the first element of the output vector `onset`
  /// is set to 0.
  ///
  /// When an onset is found, the first element of the output vector `onset` is set
  /// to `offset = 1 + a` where `a` is a number in the range`[0, 1]`.
  ///
  /// The final onset detection time, in samples, can be obtained with
  /// aubio_onset_get_last(). It can also be derived from `offset` as
  /// follows:
  ///
  /// \code
  /// t = total_frames + offset * hop_size - delay
  /// \endcode
  ///
  /// where `total_frames` is the total number of frames processed so far, and
  /// `delay` is the current delay of the onset object, as returned by
  /// aubio_onset_get_delay().
  void aubio_onset_do(
    ffi.Pointer<_aubio_onset_t> o,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> onset,
  ) {
    return _aubio_onset_do(
      o,
      input,
      onset,
    );
  }

  late final _aubio_onset_do_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_do>>('aubio_onset_do');
  late final _dart_aubio_onset_do _aubio_onset_do =
      _aubio_onset_do_ptr.asFunction<_dart_aubio_onset_do>();

  /// get the time of the latest onset detected, in samples
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  ///
  /// \return onset detection timestamps (in samples)
  int aubio_onset_get_last(
    ffi.Pointer<_aubio_onset_t> o,
  ) {
    return _aubio_onset_get_last(
      o,
    );
  }

  late final _aubio_onset_get_last_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_get_last>>(
          'aubio_onset_get_last');
  late final _dart_aubio_onset_get_last _aubio_onset_get_last =
      _aubio_onset_get_last_ptr.asFunction<_dart_aubio_onset_get_last>();

  /// get the time of the latest onset detected, in seconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  ///
  /// \return onset detection timestamps (in seconds)
  double aubio_onset_get_last_s(
    ffi.Pointer<_aubio_onset_t> o,
  ) {
    return _aubio_onset_get_last_s(
      o,
    );
  }

  late final _aubio_onset_get_last_s_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_get_last_s>>(
          'aubio_onset_get_last_s');
  late final _dart_aubio_onset_get_last_s _aubio_onset_get_last_s =
      _aubio_onset_get_last_s_ptr.asFunction<_dart_aubio_onset_get_last_s>();

  /// get the time of the latest onset detected, in milliseconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  ///
  /// \return onset detection timestamps (in milliseconds)
  double aubio_onset_get_last_ms(
    ffi.Pointer<_aubio_onset_t> o,
  ) {
    return _aubio_onset_get_last_ms(
      o,
    );
  }

  late final _aubio_onset_get_last_ms_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_get_last_ms>>(
          'aubio_onset_get_last_ms');
  late final _dart_aubio_onset_get_last_ms _aubio_onset_get_last_ms =
      _aubio_onset_get_last_ms_ptr.asFunction<_dart_aubio_onset_get_last_ms>();

  /// set onset detection adaptive whitening
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param enable 1 to enable, 0 to disable
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_onset_set_awhitening(
    ffi.Pointer<_aubio_onset_t> o,
    int enable,
  ) {
    return _aubio_onset_set_awhitening(
      o,
      enable,
    );
  }

  late final _aubio_onset_set_awhitening_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_set_awhitening>>(
          'aubio_onset_set_awhitening');
  late final _dart_aubio_onset_set_awhitening _aubio_onset_set_awhitening =
      _aubio_onset_set_awhitening_ptr
          .asFunction<_dart_aubio_onset_set_awhitening>();

  /// get onset detection adaptive whitening
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  ///
  /// \return 1 if enabled, 0 otherwise
  double aubio_onset_get_awhitening(
    ffi.Pointer<_aubio_onset_t> o,
  ) {
    return _aubio_onset_get_awhitening(
      o,
    );
  }

  late final _aubio_onset_get_awhitening_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_get_awhitening>>(
          'aubio_onset_get_awhitening');
  late final _dart_aubio_onset_get_awhitening _aubio_onset_get_awhitening =
      _aubio_onset_get_awhitening_ptr
          .asFunction<_dart_aubio_onset_get_awhitening>();

  /// set or disable log compression
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param lambda logarithmic compression factor, 0 to disable
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_onset_set_compression(
    ffi.Pointer<_aubio_onset_t> o,
    double lambda,
  ) {
    return _aubio_onset_set_compression(
      o,
      lambda,
    );
  }

  late final _aubio_onset_set_compression_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_set_compression>>(
          'aubio_onset_set_compression');
  late final _dart_aubio_onset_set_compression _aubio_onset_set_compression =
      _aubio_onset_set_compression_ptr
          .asFunction<_dart_aubio_onset_set_compression>();

  /// get onset detection log compression
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  ///
  /// \returns 0 if disabled, compression factor otherwise
  double aubio_onset_get_compression(
    ffi.Pointer<_aubio_onset_t> o,
  ) {
    return _aubio_onset_get_compression(
      o,
    );
  }

  late final _aubio_onset_get_compression_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_get_compression>>(
          'aubio_onset_get_compression');
  late final _dart_aubio_onset_get_compression _aubio_onset_get_compression =
      _aubio_onset_get_compression_ptr
          .asFunction<_dart_aubio_onset_get_compression>();

  /// set onset detection silence threshold
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param silence new silence detection threshold
  int aubio_onset_set_silence(
    ffi.Pointer<_aubio_onset_t> o,
    double silence,
  ) {
    return _aubio_onset_set_silence(
      o,
      silence,
    );
  }

  late final _aubio_onset_set_silence_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_set_silence>>(
          'aubio_onset_set_silence');
  late final _dart_aubio_onset_set_silence _aubio_onset_set_silence =
      _aubio_onset_set_silence_ptr.asFunction<_dart_aubio_onset_set_silence>();

  /// get onset detection silence threshold
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  ///
  /// \return current silence threshold
  double aubio_onset_get_silence(
    ffi.Pointer<_aubio_onset_t> o,
  ) {
    return _aubio_onset_get_silence(
      o,
    );
  }

  late final _aubio_onset_get_silence_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_get_silence>>(
          'aubio_onset_get_silence');
  late final _dart_aubio_onset_get_silence _aubio_onset_get_silence =
      _aubio_onset_get_silence_ptr.asFunction<_dart_aubio_onset_get_silence>();

  /// get onset detection function
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return the current value of the descriptor
  double aubio_onset_get_descriptor(
    ffi.Pointer<_aubio_onset_t> o,
  ) {
    return _aubio_onset_get_descriptor(
      o,
    );
  }

  late final _aubio_onset_get_descriptor_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_get_descriptor>>(
          'aubio_onset_get_descriptor');
  late final _dart_aubio_onset_get_descriptor _aubio_onset_get_descriptor =
      _aubio_onset_get_descriptor_ptr
          .asFunction<_dart_aubio_onset_get_descriptor>();

  /// get thresholded onset detection function
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return the value of the thresholded descriptor
  double aubio_onset_get_thresholded_descriptor(
    ffi.Pointer<_aubio_onset_t> o,
  ) {
    return _aubio_onset_get_thresholded_descriptor(
      o,
    );
  }

  late final _aubio_onset_get_thresholded_descriptor_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_get_thresholded_descriptor>>(
          'aubio_onset_get_thresholded_descriptor');
  late final _dart_aubio_onset_get_thresholded_descriptor
      _aubio_onset_get_thresholded_descriptor =
      _aubio_onset_get_thresholded_descriptor_ptr
          .asFunction<_dart_aubio_onset_get_thresholded_descriptor>();

  /// set onset detection peak picking threshold
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param threshold new peak-picking threshold
  int aubio_onset_set_threshold(
    ffi.Pointer<_aubio_onset_t> o,
    double threshold,
  ) {
    return _aubio_onset_set_threshold(
      o,
      threshold,
    );
  }

  late final _aubio_onset_set_threshold_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_set_threshold>>(
          'aubio_onset_set_threshold');
  late final _dart_aubio_onset_set_threshold _aubio_onset_set_threshold =
      _aubio_onset_set_threshold_ptr
          .asFunction<_dart_aubio_onset_set_threshold>();

  /// set minimum inter onset interval in samples
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param minioi minimum interval between two consecutive onsets (in
  /// samples)
  int aubio_onset_set_minioi(
    ffi.Pointer<_aubio_onset_t> o,
    int minioi,
  ) {
    return _aubio_onset_set_minioi(
      o,
      minioi,
    );
  }

  late final _aubio_onset_set_minioi_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_set_minioi>>(
          'aubio_onset_set_minioi');
  late final _dart_aubio_onset_set_minioi _aubio_onset_set_minioi =
      _aubio_onset_set_minioi_ptr.asFunction<_dart_aubio_onset_set_minioi>();

  /// set minimum inter onset interval in seconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param minioi minimum interval between two consecutive onsets (in
  /// seconds)
  int aubio_onset_set_minioi_s(
    ffi.Pointer<_aubio_onset_t> o,
    double minioi,
  ) {
    return _aubio_onset_set_minioi_s(
      o,
      minioi,
    );
  }

  late final _aubio_onset_set_minioi_s_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_set_minioi_s>>(
          'aubio_onset_set_minioi_s');
  late final _dart_aubio_onset_set_minioi_s _aubio_onset_set_minioi_s =
      _aubio_onset_set_minioi_s_ptr
          .asFunction<_dart_aubio_onset_set_minioi_s>();

  /// set minimum inter onset interval in milliseconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param minioi minimum interval between two consecutive onsets (in
  /// milliseconds)
  int aubio_onset_set_minioi_ms(
    ffi.Pointer<_aubio_onset_t> o,
    double minioi,
  ) {
    return _aubio_onset_set_minioi_ms(
      o,
      minioi,
    );
  }

  late final _aubio_onset_set_minioi_ms_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_set_minioi_ms>>(
          'aubio_onset_set_minioi_ms');
  late final _dart_aubio_onset_set_minioi_ms _aubio_onset_set_minioi_ms =
      _aubio_onset_set_minioi_ms_ptr
          .asFunction<_dart_aubio_onset_set_minioi_ms>();

  /// set delay in samples
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param delay constant system delay to take back from detection time
  /// (in samples)
  int aubio_onset_set_delay(
    ffi.Pointer<_aubio_onset_t> o,
    int delay,
  ) {
    return _aubio_onset_set_delay(
      o,
      delay,
    );
  }

  late final _aubio_onset_set_delay_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_set_delay>>(
          'aubio_onset_set_delay');
  late final _dart_aubio_onset_set_delay _aubio_onset_set_delay =
      _aubio_onset_set_delay_ptr.asFunction<_dart_aubio_onset_set_delay>();

  /// set delay in seconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param delay constant system delay to take back from detection time
  /// (in seconds)
  int aubio_onset_set_delay_s(
    ffi.Pointer<_aubio_onset_t> o,
    double delay,
  ) {
    return _aubio_onset_set_delay_s(
      o,
      delay,
    );
  }

  late final _aubio_onset_set_delay_s_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_set_delay_s>>(
          'aubio_onset_set_delay_s');
  late final _dart_aubio_onset_set_delay_s _aubio_onset_set_delay_s =
      _aubio_onset_set_delay_s_ptr.asFunction<_dart_aubio_onset_set_delay_s>();

  /// set delay in milliseconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param delay constant system delay to take back from detection time
  /// (in milliseconds)
  int aubio_onset_set_delay_ms(
    ffi.Pointer<_aubio_onset_t> o,
    double delay,
  ) {
    return _aubio_onset_set_delay_ms(
      o,
      delay,
    );
  }

  late final _aubio_onset_set_delay_ms_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_set_delay_ms>>(
          'aubio_onset_set_delay_ms');
  late final _dart_aubio_onset_set_delay_ms _aubio_onset_set_delay_ms =
      _aubio_onset_set_delay_ms_ptr
          .asFunction<_dart_aubio_onset_set_delay_ms>();

  /// get minimum inter onset interval in samples
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return minimum interval between two consecutive onsets (in
  /// samples)
  int aubio_onset_get_minioi(
    ffi.Pointer<_aubio_onset_t> o,
  ) {
    return _aubio_onset_get_minioi(
      o,
    );
  }

  late final _aubio_onset_get_minioi_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_get_minioi>>(
          'aubio_onset_get_minioi');
  late final _dart_aubio_onset_get_minioi _aubio_onset_get_minioi =
      _aubio_onset_get_minioi_ptr.asFunction<_dart_aubio_onset_get_minioi>();

  /// get minimum inter onset interval in seconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return minimum interval between two consecutive onsets (in
  /// seconds)
  double aubio_onset_get_minioi_s(
    ffi.Pointer<_aubio_onset_t> o,
  ) {
    return _aubio_onset_get_minioi_s(
      o,
    );
  }

  late final _aubio_onset_get_minioi_s_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_get_minioi_s>>(
          'aubio_onset_get_minioi_s');
  late final _dart_aubio_onset_get_minioi_s _aubio_onset_get_minioi_s =
      _aubio_onset_get_minioi_s_ptr
          .asFunction<_dart_aubio_onset_get_minioi_s>();

  /// get minimum inter onset interval in milliseconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return minimum interval between two consecutive onsets (in
  /// milliseconds)
  double aubio_onset_get_minioi_ms(
    ffi.Pointer<_aubio_onset_t> o,
  ) {
    return _aubio_onset_get_minioi_ms(
      o,
    );
  }

  late final _aubio_onset_get_minioi_ms_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_get_minioi_ms>>(
          'aubio_onset_get_minioi_ms');
  late final _dart_aubio_onset_get_minioi_ms _aubio_onset_get_minioi_ms =
      _aubio_onset_get_minioi_ms_ptr
          .asFunction<_dart_aubio_onset_get_minioi_ms>();

  /// get delay in samples
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return constant system delay to take back from detection time
  /// (in samples)
  int aubio_onset_get_delay(
    ffi.Pointer<_aubio_onset_t> o,
  ) {
    return _aubio_onset_get_delay(
      o,
    );
  }

  late final _aubio_onset_get_delay_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_get_delay>>(
          'aubio_onset_get_delay');
  late final _dart_aubio_onset_get_delay _aubio_onset_get_delay =
      _aubio_onset_get_delay_ptr.asFunction<_dart_aubio_onset_get_delay>();

  /// get delay in seconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return constant system delay to take back from detection time
  /// (in seconds)
  double aubio_onset_get_delay_s(
    ffi.Pointer<_aubio_onset_t> o,
  ) {
    return _aubio_onset_get_delay_s(
      o,
    );
  }

  late final _aubio_onset_get_delay_s_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_get_delay_s>>(
          'aubio_onset_get_delay_s');
  late final _dart_aubio_onset_get_delay_s _aubio_onset_get_delay_s =
      _aubio_onset_get_delay_s_ptr.asFunction<_dart_aubio_onset_get_delay_s>();

  /// get delay in milliseconds
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return constant system delay to take back from detection time
  /// (in milliseconds)
  double aubio_onset_get_delay_ms(
    ffi.Pointer<_aubio_onset_t> o,
  ) {
    return _aubio_onset_get_delay_ms(
      o,
    );
  }

  late final _aubio_onset_get_delay_ms_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_get_delay_ms>>(
          'aubio_onset_get_delay_ms');
  late final _dart_aubio_onset_get_delay_ms _aubio_onset_get_delay_ms =
      _aubio_onset_get_delay_ms_ptr
          .asFunction<_dart_aubio_onset_get_delay_ms>();

  /// get onset peak picking threshold
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \return current onset detection threshold
  double aubio_onset_get_threshold(
    ffi.Pointer<_aubio_onset_t> o,
  ) {
    return _aubio_onset_get_threshold(
      o,
    );
  }

  late final _aubio_onset_get_threshold_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_get_threshold>>(
          'aubio_onset_get_threshold');
  late final _dart_aubio_onset_get_threshold _aubio_onset_get_threshold =
      _aubio_onset_get_threshold_ptr
          .asFunction<_dart_aubio_onset_get_threshold>();

  /// set default parameters
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  /// \param onset_mode detection mode to adjust
  ///
  /// This function is called at the end of new_aubio_onset().
  int aubio_onset_set_default_parameters(
    ffi.Pointer<_aubio_onset_t> o,
    ffi.Pointer<ffi.Int8> onset_mode,
  ) {
    return _aubio_onset_set_default_parameters(
      o,
      onset_mode,
    );
  }

  late final _aubio_onset_set_default_parameters_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_set_default_parameters>>(
          'aubio_onset_set_default_parameters');
  late final _dart_aubio_onset_set_default_parameters
      _aubio_onset_set_default_parameters =
      _aubio_onset_set_default_parameters_ptr
          .asFunction<_dart_aubio_onset_set_default_parameters>();

  /// reset onset detection
  ///
  /// \param o onset detection object as returned by new_aubio_onset()
  ///
  /// Reset current time and last onset to 0.
  ///
  /// This function is called at the end of new_aubio_onset().
  void aubio_onset_reset(
    ffi.Pointer<_aubio_onset_t> o,
  ) {
    return _aubio_onset_reset(
      o,
    );
  }

  late final _aubio_onset_reset_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_onset_reset>>('aubio_onset_reset');
  late final _dart_aubio_onset_reset _aubio_onset_reset =
      _aubio_onset_reset_ptr.asFunction<_dart_aubio_onset_reset>();

  /// delete onset detection object
  ///
  /// \param o onset detection object to delete
  void del_aubio_onset(
    ffi.Pointer<_aubio_onset_t> o,
  ) {
    return _del_aubio_onset(
      o,
    );
  }

  late final _del_aubio_onset_ptr =
      _lookup<ffi.NativeFunction<_c_del_aubio_onset>>('del_aubio_onset');
  late final _dart_del_aubio_onset _del_aubio_onset =
      _del_aubio_onset_ptr.asFunction<_dart_del_aubio_onset>();

  /// create tempo detection object
  ///
  /// \param method beat tracking method, unused for now (use "default")
  /// \param buf_size length of FFT
  /// \param hop_size number of frames between two consecutive runs
  /// \param samplerate sampling rate of the signal to analyze
  ///
  /// \return newly created ::aubio_tempo_t if successful, `NULL` otherwise
  ffi.Pointer<_aubio_tempo_t> new_aubio_tempo(
    ffi.Pointer<ffi.Int8> method,
    int buf_size,
    int hop_size,
    int samplerate,
  ) {
    return _new_aubio_tempo(
      method,
      buf_size,
      hop_size,
      samplerate,
    );
  }

  late final _new_aubio_tempo_ptr =
      _lookup<ffi.NativeFunction<_c_new_aubio_tempo>>('new_aubio_tempo');
  late final _dart_new_aubio_tempo _new_aubio_tempo =
      _new_aubio_tempo_ptr.asFunction<_dart_new_aubio_tempo>();

  /// execute tempo detection
  ///
  /// \param o beat tracking object
  /// \param input new samples
  /// \param tempo output beats
  void aubio_tempo_do(
    ffi.Pointer<_aubio_tempo_t> o,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> tempo,
  ) {
    return _aubio_tempo_do(
      o,
      input,
      tempo,
    );
  }

  late final _aubio_tempo_do_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tempo_do>>('aubio_tempo_do');
  late final _dart_aubio_tempo_do _aubio_tempo_do =
      _aubio_tempo_do_ptr.asFunction<_dart_aubio_tempo_do>();

  /// get the time of the latest beat detected, in samples
  ///
  /// \param o tempo detection object as returned by ::new_aubio_tempo
  int aubio_tempo_get_last(
    ffi.Pointer<_aubio_tempo_t> o,
  ) {
    return _aubio_tempo_get_last(
      o,
    );
  }

  late final _aubio_tempo_get_last_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tempo_get_last>>(
          'aubio_tempo_get_last');
  late final _dart_aubio_tempo_get_last _aubio_tempo_get_last =
      _aubio_tempo_get_last_ptr.asFunction<_dart_aubio_tempo_get_last>();

  /// get the time of the latest beat detected, in seconds
  ///
  /// \param o tempo detection object as returned by ::new_aubio_tempo
  double aubio_tempo_get_last_s(
    ffi.Pointer<_aubio_tempo_t> o,
  ) {
    return _aubio_tempo_get_last_s(
      o,
    );
  }

  late final _aubio_tempo_get_last_s_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tempo_get_last_s>>(
          'aubio_tempo_get_last_s');
  late final _dart_aubio_tempo_get_last_s _aubio_tempo_get_last_s =
      _aubio_tempo_get_last_s_ptr.asFunction<_dart_aubio_tempo_get_last_s>();

  /// get the time of the latest beat detected, in milliseconds
  ///
  /// \param o tempo detection object as returned by ::new_aubio_tempo
  double aubio_tempo_get_last_ms(
    ffi.Pointer<_aubio_tempo_t> o,
  ) {
    return _aubio_tempo_get_last_ms(
      o,
    );
  }

  late final _aubio_tempo_get_last_ms_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tempo_get_last_ms>>(
          'aubio_tempo_get_last_ms');
  late final _dart_aubio_tempo_get_last_ms _aubio_tempo_get_last_ms =
      _aubio_tempo_get_last_ms_ptr.asFunction<_dart_aubio_tempo_get_last_ms>();

  /// set tempo detection silence threshold
  ///
  /// \param o beat tracking object
  /// \param silence new silence threshold, in dB
  ///
  /// \return `0` if successful, non-zero otherwise
  int aubio_tempo_set_silence(
    ffi.Pointer<_aubio_tempo_t> o,
    double silence,
  ) {
    return _aubio_tempo_set_silence(
      o,
      silence,
    );
  }

  late final _aubio_tempo_set_silence_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tempo_set_silence>>(
          'aubio_tempo_set_silence');
  late final _dart_aubio_tempo_set_silence _aubio_tempo_set_silence =
      _aubio_tempo_set_silence_ptr.asFunction<_dart_aubio_tempo_set_silence>();

  /// get tempo detection silence threshold
  ///
  /// \param o tempo detection object as returned by new_aubio_tempo()
  ///
  /// \return current silence threshold
  double aubio_tempo_get_silence(
    ffi.Pointer<_aubio_tempo_t> o,
  ) {
    return _aubio_tempo_get_silence(
      o,
    );
  }

  late final _aubio_tempo_get_silence_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tempo_get_silence>>(
          'aubio_tempo_get_silence');
  late final _dart_aubio_tempo_get_silence _aubio_tempo_get_silence =
      _aubio_tempo_get_silence_ptr.asFunction<_dart_aubio_tempo_get_silence>();

  /// set tempo detection peak picking threshold
  ///
  /// \param o beat tracking object
  /// \param threshold new threshold
  ///
  /// \return `0` if successful, non-zero otherwise
  int aubio_tempo_set_threshold(
    ffi.Pointer<_aubio_tempo_t> o,
    double threshold,
  ) {
    return _aubio_tempo_set_threshold(
      o,
      threshold,
    );
  }

  late final _aubio_tempo_set_threshold_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tempo_set_threshold>>(
          'aubio_tempo_set_threshold');
  late final _dart_aubio_tempo_set_threshold _aubio_tempo_set_threshold =
      _aubio_tempo_set_threshold_ptr
          .asFunction<_dart_aubio_tempo_set_threshold>();

  /// get tempo peak picking threshold
  ///
  /// \param o tempo detection object as returned by new_aubio_tempo()
  ///
  /// \return current tempo detection threshold
  double aubio_tempo_get_threshold(
    ffi.Pointer<_aubio_tempo_t> o,
  ) {
    return _aubio_tempo_get_threshold(
      o,
    );
  }

  late final _aubio_tempo_get_threshold_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tempo_get_threshold>>(
          'aubio_tempo_get_threshold');
  late final _dart_aubio_tempo_get_threshold _aubio_tempo_get_threshold =
      _aubio_tempo_get_threshold_ptr
          .asFunction<_dart_aubio_tempo_get_threshold>();

  /// get current beat period in samples
  ///
  /// \param bt beat tracking object
  ///
  /// Returns the currently observed period, in samples, or 0 if no consistent
  /// value is found.
  double aubio_tempo_get_period(
    ffi.Pointer<_aubio_tempo_t> bt,
  ) {
    return _aubio_tempo_get_period(
      bt,
    );
  }

  late final _aubio_tempo_get_period_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tempo_get_period>>(
          'aubio_tempo_get_period');
  late final _dart_aubio_tempo_get_period _aubio_tempo_get_period =
      _aubio_tempo_get_period_ptr.asFunction<_dart_aubio_tempo_get_period>();

  /// get current beat period in seconds
  ///
  /// \param bt beat tracking object
  ///
  /// Returns the currently observed period, in seconds, or 0 if no consistent
  /// value is found.
  double aubio_tempo_get_period_s(
    ffi.Pointer<_aubio_tempo_t> bt,
  ) {
    return _aubio_tempo_get_period_s(
      bt,
    );
  }

  late final _aubio_tempo_get_period_s_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tempo_get_period_s>>(
          'aubio_tempo_get_period_s');
  late final _dart_aubio_tempo_get_period_s _aubio_tempo_get_period_s =
      _aubio_tempo_get_period_s_ptr
          .asFunction<_dart_aubio_tempo_get_period_s>();

  /// get current tempo
  ///
  /// \param o beat tracking object
  ///
  /// \return the currently observed tempo, or `0` if no consistent value is found
  double aubio_tempo_get_bpm(
    ffi.Pointer<_aubio_tempo_t> o,
  ) {
    return _aubio_tempo_get_bpm(
      o,
    );
  }

  late final _aubio_tempo_get_bpm_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tempo_get_bpm>>(
          'aubio_tempo_get_bpm');
  late final _dart_aubio_tempo_get_bpm _aubio_tempo_get_bpm =
      _aubio_tempo_get_bpm_ptr.asFunction<_dart_aubio_tempo_get_bpm>();

  /// get current tempo confidence
  ///
  /// \param o beat tracking object
  ///
  /// \return confidence with which the tempo has been observed, the higher the
  /// more confidence, `0` if no consistent value is found.
  double aubio_tempo_get_confidence(
    ffi.Pointer<_aubio_tempo_t> o,
  ) {
    return _aubio_tempo_get_confidence(
      o,
    );
  }

  late final _aubio_tempo_get_confidence_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tempo_get_confidence>>(
          'aubio_tempo_get_confidence');
  late final _dart_aubio_tempo_get_confidence _aubio_tempo_get_confidence =
      _aubio_tempo_get_confidence_ptr
          .asFunction<_dart_aubio_tempo_get_confidence>();

  /// set number of tatum per beat
  ///
  /// \param o beat tracking object
  /// \param signature number of tatum per beat (between 1 and 64)
  int aubio_tempo_set_tatum_signature(
    ffi.Pointer<_aubio_tempo_t> o,
    int signature,
  ) {
    return _aubio_tempo_set_tatum_signature(
      o,
      signature,
    );
  }

  late final _aubio_tempo_set_tatum_signature_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tempo_set_tatum_signature>>(
          'aubio_tempo_set_tatum_signature');
  late final _dart_aubio_tempo_set_tatum_signature
      _aubio_tempo_set_tatum_signature = _aubio_tempo_set_tatum_signature_ptr
          .asFunction<_dart_aubio_tempo_set_tatum_signature>();

  /// check whether a tatum was detected in the current frame
  ///
  /// \param o beat tracking object
  ///
  /// \return 2 if a beat was detected, 1 if a tatum was detected, 0 otherwise
  int aubio_tempo_was_tatum(
    ffi.Pointer<_aubio_tempo_t> o,
  ) {
    return _aubio_tempo_was_tatum(
      o,
    );
  }

  late final _aubio_tempo_was_tatum_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tempo_was_tatum>>(
          'aubio_tempo_was_tatum');
  late final _dart_aubio_tempo_was_tatum _aubio_tempo_was_tatum =
      _aubio_tempo_was_tatum_ptr.asFunction<_dart_aubio_tempo_was_tatum>();

  /// get position of last_tatum, in samples
  ///
  /// \param o beat tracking object
  double aubio_tempo_get_last_tatum(
    ffi.Pointer<_aubio_tempo_t> o,
  ) {
    return _aubio_tempo_get_last_tatum(
      o,
    );
  }

  late final _aubio_tempo_get_last_tatum_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tempo_get_last_tatum>>(
          'aubio_tempo_get_last_tatum');
  late final _dart_aubio_tempo_get_last_tatum _aubio_tempo_get_last_tatum =
      _aubio_tempo_get_last_tatum_ptr
          .asFunction<_dart_aubio_tempo_get_last_tatum>();

  /// get current delay
  ///
  /// \param o beat tracking object
  ///
  /// \return current delay, in samples
  int aubio_tempo_get_delay(
    ffi.Pointer<_aubio_tempo_t> o,
  ) {
    return _aubio_tempo_get_delay(
      o,
    );
  }

  late final _aubio_tempo_get_delay_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tempo_get_delay>>(
          'aubio_tempo_get_delay');
  late final _dart_aubio_tempo_get_delay _aubio_tempo_get_delay =
      _aubio_tempo_get_delay_ptr.asFunction<_dart_aubio_tempo_get_delay>();

  /// get current delay in seconds
  ///
  /// \param o beat tracking object
  ///
  /// \return current delay, in seconds
  double aubio_tempo_get_delay_s(
    ffi.Pointer<_aubio_tempo_t> o,
  ) {
    return _aubio_tempo_get_delay_s(
      o,
    );
  }

  late final _aubio_tempo_get_delay_s_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tempo_get_delay_s>>(
          'aubio_tempo_get_delay_s');
  late final _dart_aubio_tempo_get_delay_s _aubio_tempo_get_delay_s =
      _aubio_tempo_get_delay_s_ptr.asFunction<_dart_aubio_tempo_get_delay_s>();

  /// get current delay in ms
  ///
  /// \param o beat tracking object
  ///
  /// \return current delay, in milliseconds
  double aubio_tempo_get_delay_ms(
    ffi.Pointer<_aubio_tempo_t> o,
  ) {
    return _aubio_tempo_get_delay_ms(
      o,
    );
  }

  late final _aubio_tempo_get_delay_ms_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tempo_get_delay_ms>>(
          'aubio_tempo_get_delay_ms');
  late final _dart_aubio_tempo_get_delay_ms _aubio_tempo_get_delay_ms =
      _aubio_tempo_get_delay_ms_ptr
          .asFunction<_dart_aubio_tempo_get_delay_ms>();

  /// set current delay
  ///
  /// \param o beat tracking object
  /// \param delay delay to set tempo to, in samples
  ///
  /// \return `0` if successful, non-zero otherwise
  int aubio_tempo_set_delay(
    ffi.Pointer<_aubio_tempo_t> o,
    int delay,
  ) {
    return _aubio_tempo_set_delay(
      o,
      delay,
    );
  }

  late final _aubio_tempo_set_delay_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tempo_set_delay>>(
          'aubio_tempo_set_delay');
  late final _dart_aubio_tempo_set_delay _aubio_tempo_set_delay =
      _aubio_tempo_set_delay_ptr.asFunction<_dart_aubio_tempo_set_delay>();

  /// set current delay in seconds
  ///
  /// \param o beat tracking object
  /// \param delay delay to set tempo to, in seconds
  ///
  /// \return `0` if successful, non-zero otherwise
  int aubio_tempo_set_delay_s(
    ffi.Pointer<_aubio_tempo_t> o,
    double delay,
  ) {
    return _aubio_tempo_set_delay_s(
      o,
      delay,
    );
  }

  late final _aubio_tempo_set_delay_s_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tempo_set_delay_s>>(
          'aubio_tempo_set_delay_s');
  late final _dart_aubio_tempo_set_delay_s _aubio_tempo_set_delay_s =
      _aubio_tempo_set_delay_s_ptr.asFunction<_dart_aubio_tempo_set_delay_s>();

  /// set current delay
  ///
  /// \param o beat tracking object
  /// \param delay delay to set tempo to, in samples
  ///
  /// \return `0` if successful, non-zero otherwise
  int aubio_tempo_set_delay_ms(
    ffi.Pointer<_aubio_tempo_t> o,
    double delay,
  ) {
    return _aubio_tempo_set_delay_ms(
      o,
      delay,
    );
  }

  late final _aubio_tempo_set_delay_ms_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_tempo_set_delay_ms>>(
          'aubio_tempo_set_delay_ms');
  late final _dart_aubio_tempo_set_delay_ms _aubio_tempo_set_delay_ms =
      _aubio_tempo_set_delay_ms_ptr
          .asFunction<_dart_aubio_tempo_set_delay_ms>();

  /// delete tempo detection object
  ///
  /// \param o beat tracking object
  void del_aubio_tempo(
    ffi.Pointer<_aubio_tempo_t> o,
  ) {
    return _del_aubio_tempo(
      o,
    );
  }

  late final _del_aubio_tempo_ptr =
      _lookup<ffi.NativeFunction<_c_del_aubio_tempo>>('del_aubio_tempo');
  late final _dart_del_aubio_tempo _del_aubio_tempo =
      _del_aubio_tempo_ptr.asFunction<_dart_del_aubio_tempo>();

  /// create notes detection object
  ///
  /// \param method notes detection type as specified in specdesc.h
  /// \param buf_size buffer size for phase vocoder
  /// \param hop_size hop size for phase vocoder
  /// \param samplerate sampling rate of the input signal
  ///
  /// \return newly created ::aubio_notes_t
  ffi.Pointer<_aubio_notes_t> new_aubio_notes(
    ffi.Pointer<ffi.Int8> method,
    int buf_size,
    int hop_size,
    int samplerate,
  ) {
    return _new_aubio_notes(
      method,
      buf_size,
      hop_size,
      samplerate,
    );
  }

  late final _new_aubio_notes_ptr =
      _lookup<ffi.NativeFunction<_c_new_aubio_notes>>('new_aubio_notes');
  late final _dart_new_aubio_notes _new_aubio_notes =
      _new_aubio_notes_ptr.asFunction<_dart_new_aubio_notes>();

  /// delete notes detection object
  ///
  /// \param o notes detection object to delete
  void del_aubio_notes(
    ffi.Pointer<_aubio_notes_t> o,
  ) {
    return _del_aubio_notes(
      o,
    );
  }

  late final _del_aubio_notes_ptr =
      _lookup<ffi.NativeFunction<_c_del_aubio_notes>>('del_aubio_notes');
  late final _dart_del_aubio_notes _del_aubio_notes =
      _del_aubio_notes_ptr.asFunction<_dart_del_aubio_notes>();

  /// execute note detection on an input signal frame
  ///
  /// \param o note detection object as returned by new_aubio_notes()
  /// \param input input signal of size [hop_size]
  /// \param output output notes, fvec of length 3
  ///
  /// The notes output is a vector of length 3 containing:
  /// - 0. the midi note value, or 0 if no note was found
  /// - 1. the note velocity
  /// - 2. the midi note to turn off
  void aubio_notes_do(
    ffi.Pointer<_aubio_notes_t> o,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> output,
  ) {
    return _aubio_notes_do(
      o,
      input,
      output,
    );
  }

  late final _aubio_notes_do_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_notes_do>>('aubio_notes_do');
  late final _dart_aubio_notes_do _aubio_notes_do =
      _aubio_notes_do_ptr.asFunction<_dart_aubio_notes_do>();

  /// set notes detection silence threshold
  ///
  /// \param o notes detection object as returned by new_aubio_notes()
  /// \param silence new silence detection threshold
  ///
  /// \return 0 on success, non-zero otherwise
  int aubio_notes_set_silence(
    ffi.Pointer<_aubio_notes_t> o,
    double silence,
  ) {
    return _aubio_notes_set_silence(
      o,
      silence,
    );
  }

  late final _aubio_notes_set_silence_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_notes_set_silence>>(
          'aubio_notes_set_silence');
  late final _dart_aubio_notes_set_silence _aubio_notes_set_silence =
      _aubio_notes_set_silence_ptr.asFunction<_dart_aubio_notes_set_silence>();

  /// get notes detection silence threshold
  ///
  /// \param o notes detection object as returned by new_aubio_notes()
  ///
  /// \return current silence threshold
  double aubio_notes_get_silence(
    ffi.Pointer<_aubio_notes_t> o,
  ) {
    return _aubio_notes_get_silence(
      o,
    );
  }

  late final _aubio_notes_get_silence_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_notes_get_silence>>(
          'aubio_notes_get_silence');
  late final _dart_aubio_notes_get_silence _aubio_notes_get_silence =
      _aubio_notes_get_silence_ptr.asFunction<_dart_aubio_notes_get_silence>();

  /// get notes detection minimum inter-onset interval, in millisecond
  ///
  /// \param o notes detection object as returned by new_aubio_notes()
  ///
  /// \return current minimum inter onset interval
  double aubio_notes_get_minioi_ms(
    ffi.Pointer<_aubio_notes_t> o,
  ) {
    return _aubio_notes_get_minioi_ms(
      o,
    );
  }

  late final _aubio_notes_get_minioi_ms_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_notes_get_minioi_ms>>(
          'aubio_notes_get_minioi_ms');
  late final _dart_aubio_notes_get_minioi_ms _aubio_notes_get_minioi_ms =
      _aubio_notes_get_minioi_ms_ptr
          .asFunction<_dart_aubio_notes_get_minioi_ms>();

  /// set notes detection minimum inter-onset interval, in millisecond
  ///
  /// \param o notes detection object as returned by new_aubio_notes()
  /// \param minioi_ms new inter-onset interval
  ///
  /// \return 0 on success, non-zero otherwise
  int aubio_notes_set_minioi_ms(
    ffi.Pointer<_aubio_notes_t> o,
    double minioi_ms,
  ) {
    return _aubio_notes_set_minioi_ms(
      o,
      minioi_ms,
    );
  }

  late final _aubio_notes_set_minioi_ms_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_notes_set_minioi_ms>>(
          'aubio_notes_set_minioi_ms');
  late final _dart_aubio_notes_set_minioi_ms _aubio_notes_set_minioi_ms =
      _aubio_notes_set_minioi_ms_ptr
          .asFunction<_dart_aubio_notes_set_minioi_ms>();

  /// get notes object release drop level, in dB
  ///
  /// \param o notes detection object as returned by new_aubio_notes()
  ///
  /// \return current release drop level, in dB
  double aubio_notes_get_release_drop(
    ffi.Pointer<_aubio_notes_t> o,
  ) {
    return _aubio_notes_get_release_drop(
      o,
    );
  }

  late final _aubio_notes_get_release_drop_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_notes_get_release_drop>>(
          'aubio_notes_get_release_drop');
  late final _dart_aubio_notes_get_release_drop _aubio_notes_get_release_drop =
      _aubio_notes_get_release_drop_ptr
          .asFunction<_dart_aubio_notes_get_release_drop>();

  /// set note release drop level, in dB
  ///
  /// This function sets the release_drop_level parameter, in dB. When a new note
  /// is found, the current level in dB is measured. If the measured level drops
  /// under that initial level - release_drop_level, then a note-off will be
  /// emitted.
  ///
  /// Defaults to `10`, in dB.
  ///
  /// \note This parameter was added in version `0.4.8`. Results obtained with
  /// earlier versions can be reproduced by setting this value to `100`, so that
  /// note-off will not be played until the next note.
  ///
  /// \param o notes detection object as returned by new_aubio_notes()
  /// \param release_drop new release drop level, in dB
  ///
  /// \return 0 on success, non-zero otherwise
  int aubio_notes_set_release_drop(
    ffi.Pointer<_aubio_notes_t> o,
    double release_drop,
  ) {
    return _aubio_notes_set_release_drop(
      o,
      release_drop,
    );
  }

  late final _aubio_notes_set_release_drop_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_notes_set_release_drop>>(
          'aubio_notes_set_release_drop');
  late final _dart_aubio_notes_set_release_drop _aubio_notes_set_release_drop =
      _aubio_notes_set_release_drop_ptr
          .asFunction<_dart_aubio_notes_set_release_drop>();

  /// create new ::aubio_source_t
  ///
  /// \param uri the file path or uri to read from
  /// \param samplerate sampling rate to view the fie at
  /// \param hop_size the size of the blocks to read from
  ///
  /// Creates a new source object. If `0` is passed as `samplerate`, the sample
  /// rate of the original file is used.
  ///
  /// The samplerate of newly created source can be obtained using
  /// ::aubio_source_get_samplerate.
  ffi.Pointer<_aubio_source_t> new_aubio_source(
    ffi.Pointer<ffi.Int8> uri,
    int samplerate,
    int hop_size,
  ) {
    return _new_aubio_source(
      uri,
      samplerate,
      hop_size,
    );
  }

  late final _new_aubio_source_ptr =
      _lookup<ffi.NativeFunction<_c_new_aubio_source>>('new_aubio_source');
  late final _dart_new_aubio_source _new_aubio_source =
      _new_aubio_source_ptr.asFunction<_dart_new_aubio_source>();

  /// read monophonic vector of length hop_size from source object
  ///
  /// \param s source object, created with ::new_aubio_source
  /// \param read_to ::fvec_t of data to read to
  /// \param read upon returns, equals to number of frames actually read
  ///
  /// Upon returns, `read` contains the number of frames actually read from the
  /// source. `hop_size` if enough frames could be read, less otherwise.
  void aubio_source_do(
    ffi.Pointer<_aubio_source_t> s,
    ffi.Pointer<fvec_t> read_to,
    ffi.Pointer<ffi.Uint32> read,
  ) {
    return _aubio_source_do(
      s,
      read_to,
      read,
    );
  }

  late final _aubio_source_do_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_source_do>>('aubio_source_do');
  late final _dart_aubio_source_do _aubio_source_do =
      _aubio_source_do_ptr.asFunction<_dart_aubio_source_do>();

  /// read polyphonic vector of length hop_size from source object
  ///
  /// \param s source object, created with ::new_aubio_source
  /// \param read_to ::fmat_t of data to read to
  /// \param[out] read upon returns, equals to number of frames actually read
  ///
  /// Upon returns, `read` contains the number of frames actually read from the
  /// source. `hop_size` if enough frames could be read, less otherwise.
  void aubio_source_do_multi(
    ffi.Pointer<_aubio_source_t> s,
    ffi.Pointer<fmat_t> read_to,
    ffi.Pointer<ffi.Uint32> read,
  ) {
    return _aubio_source_do_multi(
      s,
      read_to,
      read,
    );
  }

  late final _aubio_source_do_multi_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_source_do_multi>>(
          'aubio_source_do_multi');
  late final _dart_aubio_source_do_multi _aubio_source_do_multi =
      _aubio_source_do_multi_ptr.asFunction<_dart_aubio_source_do_multi>();

  /// get samplerate of source object
  ///
  /// \param s source object, created with ::new_aubio_source
  /// \return samplerate, in Hz
  int aubio_source_get_samplerate(
    ffi.Pointer<_aubio_source_t> s,
  ) {
    return _aubio_source_get_samplerate(
      s,
    );
  }

  late final _aubio_source_get_samplerate_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_source_get_samplerate>>(
          'aubio_source_get_samplerate');
  late final _dart_aubio_source_get_samplerate _aubio_source_get_samplerate =
      _aubio_source_get_samplerate_ptr
          .asFunction<_dart_aubio_source_get_samplerate>();

  /// get channels of source object
  ///
  /// \param s source object, created with ::new_aubio_source
  /// \return channels
  int aubio_source_get_channels(
    ffi.Pointer<_aubio_source_t> s,
  ) {
    return _aubio_source_get_channels(
      s,
    );
  }

  late final _aubio_source_get_channels_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_source_get_channels>>(
          'aubio_source_get_channels');
  late final _dart_aubio_source_get_channels _aubio_source_get_channels =
      _aubio_source_get_channels_ptr
          .asFunction<_dart_aubio_source_get_channels>();

  /// seek source object
  ///
  /// \param s source object, created with ::new_aubio_source
  /// \param pos position to seek to, in frames
  ///
  /// \return 0 if sucessful, non-zero on failure
  int aubio_source_seek(
    ffi.Pointer<_aubio_source_t> s,
    int pos,
  ) {
    return _aubio_source_seek(
      s,
      pos,
    );
  }

  late final _aubio_source_seek_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_source_seek>>('aubio_source_seek');
  late final _dart_aubio_source_seek _aubio_source_seek =
      _aubio_source_seek_ptr.asFunction<_dart_aubio_source_seek>();

  /// get the duration of source object, in frames
  ///
  /// \param s source object, created with ::new_aubio_source
  /// \return number of frames in file
  int aubio_source_get_duration(
    ffi.Pointer<_aubio_source_t> s,
  ) {
    return _aubio_source_get_duration(
      s,
    );
  }

  late final _aubio_source_get_duration_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_source_get_duration>>(
          'aubio_source_get_duration');
  late final _dart_aubio_source_get_duration _aubio_source_get_duration =
      _aubio_source_get_duration_ptr
          .asFunction<_dart_aubio_source_get_duration>();

  /// close source object
  ///
  /// \param s source object, created with ::new_aubio_source
  ///
  /// \return 0 if sucessful, non-zero on failure
  int aubio_source_close(
    ffi.Pointer<_aubio_source_t> s,
  ) {
    return _aubio_source_close(
      s,
    );
  }

  late final _aubio_source_close_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_source_close>>('aubio_source_close');
  late final _dart_aubio_source_close _aubio_source_close =
      _aubio_source_close_ptr.asFunction<_dart_aubio_source_close>();

  /// close source and cleanup memory
  ///
  /// \param s source object, created with ::new_aubio_source
  void del_aubio_source(
    ffi.Pointer<_aubio_source_t> s,
  ) {
    return _del_aubio_source(
      s,
    );
  }

  late final _del_aubio_source_ptr =
      _lookup<ffi.NativeFunction<_c_del_aubio_source>>('del_aubio_source');
  late final _dart_del_aubio_source _del_aubio_source =
      _del_aubio_source_ptr.asFunction<_dart_del_aubio_source>();

  /// create new ::aubio_sink_t
  ///
  /// \param uri the file path or uri to write to
  /// \param samplerate sample rate to write the file at
  ///
  /// \return newly created ::aubio_sink_t
  ///
  /// Creates a new sink object.
  ///
  /// If samplerate is set to 0, the creation of the file will be delayed until
  /// both ::aubio_sink_preset_samplerate and ::aubio_sink_preset_channels have
  /// been called.
  ffi.Pointer<_aubio_sink_t> new_aubio_sink(
    ffi.Pointer<ffi.Int8> uri,
    int samplerate,
  ) {
    return _new_aubio_sink(
      uri,
      samplerate,
    );
  }

  late final _new_aubio_sink_ptr =
      _lookup<ffi.NativeFunction<_c_new_aubio_sink>>('new_aubio_sink');
  late final _dart_new_aubio_sink _new_aubio_sink =
      _new_aubio_sink_ptr.asFunction<_dart_new_aubio_sink>();

  /// preset sink samplerate
  ///
  /// \param s sink, created with ::new_aubio_sink
  /// \param samplerate samplerate to preset the sink to, in Hz
  ///
  /// \return 0 on success, 1 on error
  ///
  /// Preset the samplerate of the sink. The file should have been created using a
  /// samplerate of 0.
  ///
  /// The file will be opened only when both samplerate and channels have been set.
  int aubio_sink_preset_samplerate(
    ffi.Pointer<_aubio_sink_t> s,
    int samplerate,
  ) {
    return _aubio_sink_preset_samplerate(
      s,
      samplerate,
    );
  }

  late final _aubio_sink_preset_samplerate_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_sink_preset_samplerate>>(
          'aubio_sink_preset_samplerate');
  late final _dart_aubio_sink_preset_samplerate _aubio_sink_preset_samplerate =
      _aubio_sink_preset_samplerate_ptr
          .asFunction<_dart_aubio_sink_preset_samplerate>();

  /// preset sink channels
  ///
  /// \param s sink, created with ::new_aubio_sink
  /// \param channels number of channels to preset the sink to
  ///
  /// \return 0 on success, 1 on error
  ///
  /// Preset the samplerate of the sink. The file should have been created using a
  /// samplerate of 0.
  ///
  /// The file will be opened only when both samplerate and channels have been set.
  int aubio_sink_preset_channels(
    ffi.Pointer<_aubio_sink_t> s,
    int channels,
  ) {
    return _aubio_sink_preset_channels(
      s,
      channels,
    );
  }

  late final _aubio_sink_preset_channels_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_sink_preset_channels>>(
          'aubio_sink_preset_channels');
  late final _dart_aubio_sink_preset_channels _aubio_sink_preset_channels =
      _aubio_sink_preset_channels_ptr
          .asFunction<_dart_aubio_sink_preset_channels>();

  /// get samplerate of sink object
  ///
  /// \param s sink object, created with ::new_aubio_sink
  /// \return samplerate, in Hz
  int aubio_sink_get_samplerate(
    ffi.Pointer<_aubio_sink_t> s,
  ) {
    return _aubio_sink_get_samplerate(
      s,
    );
  }

  late final _aubio_sink_get_samplerate_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_sink_get_samplerate>>(
          'aubio_sink_get_samplerate');
  late final _dart_aubio_sink_get_samplerate _aubio_sink_get_samplerate =
      _aubio_sink_get_samplerate_ptr
          .asFunction<_dart_aubio_sink_get_samplerate>();

  /// get channels of sink object
  ///
  /// \param s sink object, created with ::new_aubio_sink
  /// \return number of channels
  int aubio_sink_get_channels(
    ffi.Pointer<_aubio_sink_t> s,
  ) {
    return _aubio_sink_get_channels(
      s,
    );
  }

  late final _aubio_sink_get_channels_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_sink_get_channels>>(
          'aubio_sink_get_channels');
  late final _dart_aubio_sink_get_channels _aubio_sink_get_channels =
      _aubio_sink_get_channels_ptr.asFunction<_dart_aubio_sink_get_channels>();

  /// write monophonic vector of length hop_size to sink
  ///
  /// \param s sink, created with ::new_aubio_sink
  /// \param write_data ::fvec_t samples to write to sink
  /// \param write number of frames to write
  void aubio_sink_do(
    ffi.Pointer<_aubio_sink_t> s,
    ffi.Pointer<fvec_t> write_data,
    int write,
  ) {
    return _aubio_sink_do(
      s,
      write_data,
      write,
    );
  }

  late final _aubio_sink_do_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_sink_do>>('aubio_sink_do');
  late final _dart_aubio_sink_do _aubio_sink_do =
      _aubio_sink_do_ptr.asFunction<_dart_aubio_sink_do>();

  /// write polyphonic vector of length hop_size to sink
  ///
  /// \param s sink, created with ::new_aubio_sink
  /// \param write_data ::fmat_t samples to write to sink
  /// \param write number of frames to write
  void aubio_sink_do_multi(
    ffi.Pointer<_aubio_sink_t> s,
    ffi.Pointer<fmat_t> write_data,
    int write,
  ) {
    return _aubio_sink_do_multi(
      s,
      write_data,
      write,
    );
  }

  late final _aubio_sink_do_multi_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_sink_do_multi>>(
          'aubio_sink_do_multi');
  late final _dart_aubio_sink_do_multi _aubio_sink_do_multi =
      _aubio_sink_do_multi_ptr.asFunction<_dart_aubio_sink_do_multi>();

  /// close sink
  ///
  /// \param s sink object, created with ::new_aubio_sink
  ///
  /// \return 0 on success, non-zero on failure
  int aubio_sink_close(
    ffi.Pointer<_aubio_sink_t> s,
  ) {
    return _aubio_sink_close(
      s,
    );
  }

  late final _aubio_sink_close_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_sink_close>>('aubio_sink_close');
  late final _dart_aubio_sink_close _aubio_sink_close =
      _aubio_sink_close_ptr.asFunction<_dart_aubio_sink_close>();

  /// close sink and cleanup memory
  ///
  /// \param s sink object, created with ::new_aubio_sink
  void del_aubio_sink(
    ffi.Pointer<_aubio_sink_t> s,
  ) {
    return _del_aubio_sink(
      s,
    );
  }

  late final _del_aubio_sink_ptr =
      _lookup<ffi.NativeFunction<_c_del_aubio_sink>>('del_aubio_sink');
  late final _dart_del_aubio_sink _del_aubio_sink =
      _del_aubio_sink_ptr.asFunction<_dart_del_aubio_sink>();

  /// create new sampler object
  ///
  /// \param samplerate the sampling rate of the new sampler
  /// \param hop_size the block size of the new sampler
  ///
  /// \return the newly created ::aubio_sampler_t
  ffi.Pointer<_aubio_sampler_t> new_aubio_sampler(
    int samplerate,
    int hop_size,
  ) {
    return _new_aubio_sampler(
      samplerate,
      hop_size,
    );
  }

  late final _new_aubio_sampler_ptr =
      _lookup<ffi.NativeFunction<_c_new_aubio_sampler>>('new_aubio_sampler');
  late final _dart_new_aubio_sampler _new_aubio_sampler =
      _new_aubio_sampler_ptr.asFunction<_dart_new_aubio_sampler>();

  /// load source in sampler
  ///
  /// \param o sampler, created by new_aubio_sampler()
  /// \param uri the uri of the source to load
  ///
  /// \return 0 if successful, non-zero otherwise
  int aubio_sampler_load(
    ffi.Pointer<_aubio_sampler_t> o,
    ffi.Pointer<ffi.Int8> uri,
  ) {
    return _aubio_sampler_load(
      o,
      uri,
    );
  }

  late final _aubio_sampler_load_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_sampler_load>>('aubio_sampler_load');
  late final _dart_aubio_sampler_load _aubio_sampler_load =
      _aubio_sampler_load_ptr.asFunction<_dart_aubio_sampler_load>();

  /// process sampler function
  ///
  /// \param o sampler, created by new_aubio_sampler()
  /// \param input input of the sampler, to be added to the output
  /// \param output output of the sampler
  ///
  /// This function adds the new samples from the playing source to the output.
  ///
  /// If `input` is not NULL and different from `output`, then the samples from `input`
  /// are added to the output.
  void aubio_sampler_do(
    ffi.Pointer<_aubio_sampler_t> o,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> output,
  ) {
    return _aubio_sampler_do(
      o,
      input,
      output,
    );
  }

  late final _aubio_sampler_do_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_sampler_do>>('aubio_sampler_do');
  late final _dart_aubio_sampler_do _aubio_sampler_do =
      _aubio_sampler_do_ptr.asFunction<_dart_aubio_sampler_do>();

  /// process sampler function, multiple channels
  ///
  /// \param o sampler, created by new_aubio_sampler()
  /// \param input input of the sampler, to be added to the output
  /// \param output output of the sampler
  ///
  /// This function adds the new samples from the playing source to the output.
  ///
  /// If `input` is not NULL and different from `output`, then the samples from `input`
  /// are added to the output.
  void aubio_sampler_do_multi(
    ffi.Pointer<_aubio_sampler_t> o,
    ffi.Pointer<fmat_t> input,
    ffi.Pointer<fmat_t> output,
  ) {
    return _aubio_sampler_do_multi(
      o,
      input,
      output,
    );
  }

  late final _aubio_sampler_do_multi_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_sampler_do_multi>>(
          'aubio_sampler_do_multi');
  late final _dart_aubio_sampler_do_multi _aubio_sampler_do_multi =
      _aubio_sampler_do_multi_ptr.asFunction<_dart_aubio_sampler_do_multi>();

  /// get current playing state
  ///
  /// \param o sampler, created by new_aubio_sampler()
  ///
  /// \return 0 if not playing, 1 if playing
  int aubio_sampler_get_playing(
    ffi.Pointer<_aubio_sampler_t> o,
  ) {
    return _aubio_sampler_get_playing(
      o,
    );
  }

  late final _aubio_sampler_get_playing_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_sampler_get_playing>>(
          'aubio_sampler_get_playing');
  late final _dart_aubio_sampler_get_playing _aubio_sampler_get_playing =
      _aubio_sampler_get_playing_ptr
          .asFunction<_dart_aubio_sampler_get_playing>();

  /// set current playing state
  ///
  /// \param o sampler, created by new_aubio_sampler()
  /// \param playing 0 for not playing, 1 for playing
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_sampler_set_playing(
    ffi.Pointer<_aubio_sampler_t> o,
    int playing,
  ) {
    return _aubio_sampler_set_playing(
      o,
      playing,
    );
  }

  late final _aubio_sampler_set_playing_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_sampler_set_playing>>(
          'aubio_sampler_set_playing');
  late final _dart_aubio_sampler_set_playing _aubio_sampler_set_playing =
      _aubio_sampler_set_playing_ptr
          .asFunction<_dart_aubio_sampler_set_playing>();

  /// play sample from start
  ///
  /// \param o sampler, created by new_aubio_sampler()
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_sampler_play(
    ffi.Pointer<_aubio_sampler_t> o,
  ) {
    return _aubio_sampler_play(
      o,
    );
  }

  late final _aubio_sampler_play_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_sampler_play>>('aubio_sampler_play');
  late final _dart_aubio_sampler_play _aubio_sampler_play =
      _aubio_sampler_play_ptr.asFunction<_dart_aubio_sampler_play>();

  /// stop sample
  ///
  /// \param o sampler, created by new_aubio_sampler()
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_sampler_stop(
    ffi.Pointer<_aubio_sampler_t> o,
  ) {
    return _aubio_sampler_stop(
      o,
    );
  }

  late final _aubio_sampler_stop_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_sampler_stop>>('aubio_sampler_stop');
  late final _dart_aubio_sampler_stop _aubio_sampler_stop =
      _aubio_sampler_stop_ptr.asFunction<_dart_aubio_sampler_stop>();

  /// destroy ::aubio_sampler_t object
  ///
  /// \param o sampler, created by new_aubio_sampler()
  void del_aubio_sampler(
    ffi.Pointer<_aubio_sampler_t> o,
  ) {
    return _del_aubio_sampler(
      o,
    );
  }

  late final _del_aubio_sampler_ptr =
      _lookup<ffi.NativeFunction<_c_del_aubio_sampler>>('del_aubio_sampler');
  late final _dart_del_aubio_sampler _del_aubio_sampler =
      _del_aubio_sampler_ptr.asFunction<_dart_del_aubio_sampler>();

  /// create new wavetable object
  ///
  /// \param samplerate the sampling rate of the new wavetable
  /// \param hop_size the block size of the new wavetable
  ///
  /// \return the newly created aubio_wavetable_t
  ffi.Pointer<_aubio_wavetable_t> new_aubio_wavetable(
    int samplerate,
    int hop_size,
  ) {
    return _new_aubio_wavetable(
      samplerate,
      hop_size,
    );
  }

  late final _new_aubio_wavetable_ptr =
      _lookup<ffi.NativeFunction<_c_new_aubio_wavetable>>(
          'new_aubio_wavetable');
  late final _dart_new_aubio_wavetable _new_aubio_wavetable =
      _new_aubio_wavetable_ptr.asFunction<_dart_new_aubio_wavetable>();

  /// load source in wavetable
  ///
  /// TODO: This function is not implemented yet. See new_aubio_sampler() instead.
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  /// \param uri the uri of the source to load
  ///
  /// \return 0 if successful, non-zero otherwise
  int aubio_wavetable_load(
    ffi.Pointer<_aubio_wavetable_t> o,
    ffi.Pointer<ffi.Int8> uri,
  ) {
    return _aubio_wavetable_load(
      o,
      uri,
    );
  }

  late final _aubio_wavetable_load_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_wavetable_load>>(
          'aubio_wavetable_load');
  late final _dart_aubio_wavetable_load _aubio_wavetable_load =
      _aubio_wavetable_load_ptr.asFunction<_dart_aubio_wavetable_load>();

  /// process wavetable function
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  /// \param input input of the wavetable, to be added to the output
  /// \param output output of the wavetable
  ///
  /// This function adds the new samples from the playing wavetable to the output.
  ///
  /// If `input` is not NULL and different from `output`, then the samples from `input`
  /// are added to the output.
  void aubio_wavetable_do(
    ffi.Pointer<_aubio_wavetable_t> o,
    ffi.Pointer<fvec_t> input,
    ffi.Pointer<fvec_t> output,
  ) {
    return _aubio_wavetable_do(
      o,
      input,
      output,
    );
  }

  late final _aubio_wavetable_do_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_wavetable_do>>('aubio_wavetable_do');
  late final _dart_aubio_wavetable_do _aubio_wavetable_do =
      _aubio_wavetable_do_ptr.asFunction<_dart_aubio_wavetable_do>();

  /// process wavetable function, multiple channels
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  /// \param input input of the wavetable, to be added to the output
  /// \param output output of the wavetable
  ///
  /// This function adds the new samples from the playing wavetable to the output.
  ///
  /// If `input` is not NULL and different from `output`, then the samples from `input`
  /// are added to the output.
  void aubio_wavetable_do_multi(
    ffi.Pointer<_aubio_wavetable_t> o,
    ffi.Pointer<fmat_t> input,
    ffi.Pointer<fmat_t> output,
  ) {
    return _aubio_wavetable_do_multi(
      o,
      input,
      output,
    );
  }

  late final _aubio_wavetable_do_multi_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_wavetable_do_multi>>(
          'aubio_wavetable_do_multi');
  late final _dart_aubio_wavetable_do_multi _aubio_wavetable_do_multi =
      _aubio_wavetable_do_multi_ptr
          .asFunction<_dart_aubio_wavetable_do_multi>();

  /// get current playing state
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  ///
  /// \return 0 if not playing, 1 if playing
  int aubio_wavetable_get_playing(
    ffi.Pointer<_aubio_wavetable_t> o,
  ) {
    return _aubio_wavetable_get_playing(
      o,
    );
  }

  late final _aubio_wavetable_get_playing_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_wavetable_get_playing>>(
          'aubio_wavetable_get_playing');
  late final _dart_aubio_wavetable_get_playing _aubio_wavetable_get_playing =
      _aubio_wavetable_get_playing_ptr
          .asFunction<_dart_aubio_wavetable_get_playing>();

  /// set current playing state
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  /// \param playing 0 for not playing, 1 for playing
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_wavetable_set_playing(
    ffi.Pointer<_aubio_wavetable_t> o,
    int playing,
  ) {
    return _aubio_wavetable_set_playing(
      o,
      playing,
    );
  }

  late final _aubio_wavetable_set_playing_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_wavetable_set_playing>>(
          'aubio_wavetable_set_playing');
  late final _dart_aubio_wavetable_set_playing _aubio_wavetable_set_playing =
      _aubio_wavetable_set_playing_ptr
          .asFunction<_dart_aubio_wavetable_set_playing>();

  /// play sample from start
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_wavetable_play(
    ffi.Pointer<_aubio_wavetable_t> o,
  ) {
    return _aubio_wavetable_play(
      o,
    );
  }

  late final _aubio_wavetable_play_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_wavetable_play>>(
          'aubio_wavetable_play');
  late final _dart_aubio_wavetable_play _aubio_wavetable_play =
      _aubio_wavetable_play_ptr.asFunction<_dart_aubio_wavetable_play>();

  /// stop wavetable
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_wavetable_stop(
    ffi.Pointer<_aubio_wavetable_t> o,
  ) {
    return _aubio_wavetable_stop(
      o,
    );
  }

  late final _aubio_wavetable_stop_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_wavetable_stop>>(
          'aubio_wavetable_stop');
  late final _dart_aubio_wavetable_stop _aubio_wavetable_stop =
      _aubio_wavetable_stop_ptr.asFunction<_dart_aubio_wavetable_stop>();

  /// set wavetable frequency
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  /// \param freq new frequency value for the wavetable
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_wavetable_set_freq(
    ffi.Pointer<_aubio_wavetable_t> o,
    double freq,
  ) {
    return _aubio_wavetable_set_freq(
      o,
      freq,
    );
  }

  late final _aubio_wavetable_set_freq_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_wavetable_set_freq>>(
          'aubio_wavetable_set_freq');
  late final _dart_aubio_wavetable_set_freq _aubio_wavetable_set_freq =
      _aubio_wavetable_set_freq_ptr
          .asFunction<_dart_aubio_wavetable_set_freq>();

  /// get wavetable frequency
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  ///
  /// \return current frequency, in Hz
  double aubio_wavetable_get_freq(
    ffi.Pointer<_aubio_wavetable_t> o,
  ) {
    return _aubio_wavetable_get_freq(
      o,
    );
  }

  late final _aubio_wavetable_get_freq_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_wavetable_get_freq>>(
          'aubio_wavetable_get_freq');
  late final _dart_aubio_wavetable_get_freq _aubio_wavetable_get_freq =
      _aubio_wavetable_get_freq_ptr
          .asFunction<_dart_aubio_wavetable_get_freq>();

  /// set wavetable amplitude
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  /// \param amp new amplitude value for the wavetable
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_wavetable_set_amp(
    ffi.Pointer<_aubio_wavetable_t> o,
    double amp,
  ) {
    return _aubio_wavetable_set_amp(
      o,
      amp,
    );
  }

  late final _aubio_wavetable_set_amp_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_wavetable_set_amp>>(
          'aubio_wavetable_set_amp');
  late final _dart_aubio_wavetable_set_amp _aubio_wavetable_set_amp =
      _aubio_wavetable_set_amp_ptr.asFunction<_dart_aubio_wavetable_set_amp>();

  /// get wavetable amplitude
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  ///
  /// \return current amplitude
  double aubio_wavetable_get_amp(
    ffi.Pointer<_aubio_wavetable_t> o,
  ) {
    return _aubio_wavetable_get_amp(
      o,
    );
  }

  late final _aubio_wavetable_get_amp_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_wavetable_get_amp>>(
          'aubio_wavetable_get_amp');
  late final _dart_aubio_wavetable_get_amp _aubio_wavetable_get_amp =
      _aubio_wavetable_get_amp_ptr.asFunction<_dart_aubio_wavetable_get_amp>();

  /// destroy aubio_wavetable_t object
  ///
  /// \param o wavetable, created by new_aubio_wavetable()
  void del_aubio_wavetable(
    ffi.Pointer<_aubio_wavetable_t> o,
  ) {
    return _del_aubio_wavetable(
      o,
    );
  }

  late final _del_aubio_wavetable_ptr =
      _lookup<ffi.NativeFunction<_c_del_aubio_wavetable>>(
          'del_aubio_wavetable');
  late final _dart_del_aubio_wavetable _del_aubio_wavetable =
      _del_aubio_wavetable_ptr.asFunction<_dart_del_aubio_wavetable>();

  /// create new parameter object
  ///
  /// \param min_value the minimum value of the new parameter
  /// \param max_value the maximum value of the new parameter
  /// \param steps the number of steps to interpolate from the old value to the target value
  ///
  /// \return the newly created ::aubio_parameter_t
  ffi.Pointer<_aubio_parameter_t> new_aubio_parameter(
    double min_value,
    double max_value,
    int steps,
  ) {
    return _new_aubio_parameter(
      min_value,
      max_value,
      steps,
    );
  }

  late final _new_aubio_parameter_ptr =
      _lookup<ffi.NativeFunction<_c_new_aubio_parameter>>(
          'new_aubio_parameter');
  late final _dart_new_aubio_parameter _new_aubio_parameter =
      _new_aubio_parameter_ptr.asFunction<_dart_new_aubio_parameter>();

  /// set target value of the parameter
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  /// \param value new target value
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_parameter_set_target_value(
    ffi.Pointer<_aubio_parameter_t> param,
    double value,
  ) {
    return _aubio_parameter_set_target_value(
      param,
      value,
    );
  }

  late final _aubio_parameter_set_target_value_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_parameter_set_target_value>>(
          'aubio_parameter_set_target_value');
  late final _dart_aubio_parameter_set_target_value
      _aubio_parameter_set_target_value = _aubio_parameter_set_target_value_ptr
          .asFunction<_dart_aubio_parameter_set_target_value>();

  /// get next parameter
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  ///
  /// \return new interpolated parameter value
  double aubio_parameter_get_next_value(
    ffi.Pointer<_aubio_parameter_t> param,
  ) {
    return _aubio_parameter_get_next_value(
      param,
    );
  }

  late final _aubio_parameter_get_next_value_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_parameter_get_next_value>>(
          'aubio_parameter_get_next_value');
  late final _dart_aubio_parameter_get_next_value
      _aubio_parameter_get_next_value = _aubio_parameter_get_next_value_ptr
          .asFunction<_dart_aubio_parameter_get_next_value>();

  /// get current parameter value, without interpolation
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  ///
  /// \return current value
  double aubio_parameter_get_current_value(
    ffi.Pointer<_aubio_parameter_t> param,
  ) {
    return _aubio_parameter_get_current_value(
      param,
    );
  }

  late final _aubio_parameter_get_current_value_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_parameter_get_current_value>>(
          'aubio_parameter_get_current_value');
  late final _dart_aubio_parameter_get_current_value
      _aubio_parameter_get_current_value =
      _aubio_parameter_get_current_value_ptr
          .asFunction<_dart_aubio_parameter_get_current_value>();

  /// set current parameter value, skipping interpolation
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  /// \param value new parameter value
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_parameter_set_current_value(
    ffi.Pointer<_aubio_parameter_t> param,
    double value,
  ) {
    return _aubio_parameter_set_current_value(
      param,
      value,
    );
  }

  late final _aubio_parameter_set_current_value_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_parameter_set_current_value>>(
          'aubio_parameter_set_current_value');
  late final _dart_aubio_parameter_set_current_value
      _aubio_parameter_set_current_value =
      _aubio_parameter_set_current_value_ptr
          .asFunction<_dart_aubio_parameter_set_current_value>();

  /// set number of steps used for interpolation
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  /// \param steps new number of steps
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_parameter_set_steps(
    ffi.Pointer<_aubio_parameter_t> param,
    int steps,
  ) {
    return _aubio_parameter_set_steps(
      param,
      steps,
    );
  }

  late final _aubio_parameter_set_steps_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_parameter_set_steps>>(
          'aubio_parameter_set_steps');
  late final _dart_aubio_parameter_set_steps _aubio_parameter_set_steps =
      _aubio_parameter_set_steps_ptr
          .asFunction<_dart_aubio_parameter_set_steps>();

  /// get number of steps of this parameter
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  ///
  /// \return number of steps
  int aubio_parameter_get_steps(
    ffi.Pointer<_aubio_parameter_t> param,
  ) {
    return _aubio_parameter_get_steps(
      param,
    );
  }

  late final _aubio_parameter_get_steps_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_parameter_get_steps>>(
          'aubio_parameter_get_steps');
  late final _dart_aubio_parameter_get_steps _aubio_parameter_get_steps =
      _aubio_parameter_get_steps_ptr
          .asFunction<_dart_aubio_parameter_get_steps>();

  /// set minimum value of this parameter
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  /// \param min_value new minimum value
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_parameter_set_min_value(
    ffi.Pointer<_aubio_parameter_t> param,
    double min_value,
  ) {
    return _aubio_parameter_set_min_value(
      param,
      min_value,
    );
  }

  late final _aubio_parameter_set_min_value_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_parameter_set_min_value>>(
          'aubio_parameter_set_min_value');
  late final _dart_aubio_parameter_set_min_value
      _aubio_parameter_set_min_value = _aubio_parameter_set_min_value_ptr
          .asFunction<_dart_aubio_parameter_set_min_value>();

  /// get minimum value of this parameter
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  ///
  /// \return minimum value
  double aubio_parameter_get_min_value(
    ffi.Pointer<_aubio_parameter_t> param,
  ) {
    return _aubio_parameter_get_min_value(
      param,
    );
  }

  late final _aubio_parameter_get_min_value_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_parameter_get_min_value>>(
          'aubio_parameter_get_min_value');
  late final _dart_aubio_parameter_get_min_value
      _aubio_parameter_get_min_value = _aubio_parameter_get_min_value_ptr
          .asFunction<_dart_aubio_parameter_get_min_value>();

  /// set maximum value of this parameter
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  /// \param max_value new maximum value
  ///
  /// \return 0 if successful, 1 otherwise
  int aubio_parameter_set_max_value(
    ffi.Pointer<_aubio_parameter_t> param,
    double max_value,
  ) {
    return _aubio_parameter_set_max_value(
      param,
      max_value,
    );
  }

  late final _aubio_parameter_set_max_value_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_parameter_set_max_value>>(
          'aubio_parameter_set_max_value');
  late final _dart_aubio_parameter_set_max_value
      _aubio_parameter_set_max_value = _aubio_parameter_set_max_value_ptr
          .asFunction<_dart_aubio_parameter_set_max_value>();

  /// get maximum value of this parameter
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  ///
  /// \return maximum value
  double aubio_parameter_get_max_value(
    ffi.Pointer<_aubio_parameter_t> param,
  ) {
    return _aubio_parameter_get_max_value(
      param,
    );
  }

  late final _aubio_parameter_get_max_value_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_parameter_get_max_value>>(
          'aubio_parameter_get_max_value');
  late final _dart_aubio_parameter_get_max_value
      _aubio_parameter_get_max_value = _aubio_parameter_get_max_value_ptr
          .asFunction<_dart_aubio_parameter_get_max_value>();

  /// destroy ::aubio_parameter_t object
  ///
  /// \param param parameter, created by ::new_aubio_parameter
  void del_aubio_parameter(
    ffi.Pointer<_aubio_parameter_t> param,
  ) {
    return _del_aubio_parameter(
      param,
    );
  }

  late final _del_aubio_parameter_ptr =
      _lookup<ffi.NativeFunction<_c_del_aubio_parameter>>(
          'del_aubio_parameter');
  late final _dart_del_aubio_parameter _del_aubio_parameter =
      _del_aubio_parameter_ptr.asFunction<_dart_del_aubio_parameter>();

  /// Set logging function for all levels
  ///
  /// \param fun the function to be used to log, of type ::aubio_log_function_t
  /// \param data optional closure to be passed to the function (can be NULL if
  /// nothing to pass)
  void aubio_log_set_function(
    ffi.Pointer<ffi.NativeFunction<aubio_log_function_t>> fun,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _aubio_log_set_function(
      fun,
      data,
    );
  }

  late final _aubio_log_set_function_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_log_set_function>>(
          'aubio_log_set_function');
  late final _dart_aubio_log_set_function _aubio_log_set_function =
      _aubio_log_set_function_ptr.asFunction<_dart_aubio_log_set_function>();

  /// Set logging function for a given level
  ///
  /// \param level the level for which to set the logging function
  /// \param fun the function to be used to log, of type ::aubio_log_function_t
  /// \param data optional closure to be passed to the function (can be NULL if
  /// nothing to pass)
  ffi.Pointer<ffi.NativeFunction<aubio_log_function_t>>
      aubio_log_set_level_function(
    int level,
    ffi.Pointer<ffi.NativeFunction<aubio_log_function_t>> fun,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _aubio_log_set_level_function(
      level,
      fun,
      data,
    );
  }

  late final _aubio_log_set_level_function_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_log_set_level_function>>(
          'aubio_log_set_level_function');
  late final _dart_aubio_log_set_level_function _aubio_log_set_level_function =
      _aubio_log_set_level_function_ptr
          .asFunction<_dart_aubio_log_set_level_function>();

  /// Reset all logging functions to the default one
  ///
  /// After calling this function, the default logging function will be used to
  /// print error, warning, normal, and debug messages to `stdout` or `stderr`.
  void aubio_log_reset() {
    return _aubio_log_reset();
  }

  late final _aubio_log_reset_ptr =
      _lookup<ffi.NativeFunction<_c_aubio_log_reset>>('aubio_log_reset');
  late final _dart_aubio_log_reset _aubio_log_reset =
      _aubio_log_reset_ptr.asFunction<_dart_aubio_log_reset>();
}

/// Buffer for real data
///
/// Vector of real-valued data
///
/// ::fvec_t is is the structure used to store vector of real-valued data, ::smpl_t .
///
/// \code
///
/// uint_t buffer_size = 1024;
///
/// // create a vector of 512 values
/// fvec_t * input = new_fvec (buffer_size);
///
/// // set some values of the vector
/// input->data[23] = 2.;
/// // ..
///
/// // compute the mean of the vector
/// mean = fvec_mean(a_vector);
///
/// // destroy the vector
/// del_fvec(a_vector);
///
/// \endcode
///
/// See `examples/` and `tests/src` directories for more examples.
class fvec_t extends ffi.Struct {
  /// < length of buffer
  @ffi.Uint32()
  external int length;

  /// < data vector of length ::fvec_t.length
  external ffi.Pointer<ffi.Float> data;
}

/// Vector of real-valued phase and spectrum data
///
/// \code
///
/// uint_t buffer_size = 1024;
///
/// // create a complex vector of 512 values
/// cvec_t * input = new_cvec (buffer_size);
///
/// // set some values of the vector
/// input->norm[23] = 2.;
/// input->phas[23] = M_PI;
/// // ..
///
/// // compute the mean of the vector
/// mean = cvec_mean(input);
///
/// // destroy the vector
/// del_cvec (input);
///
/// \endcode
class cvec_t extends ffi.Struct {
  /// < length of buffer = (requested length)/2 + 1
  @ffi.Uint32()
  external int length;

  /// < norm array of size ::cvec_t.length
  external ffi.Pointer<ffi.Float> norm;

  /// < phase array of size ::cvec_t.length
  external ffi.Pointer<ffi.Float> phas;
}

/// Buffer for real data in double precision
class lvec_t extends ffi.Struct {
  /// < length of buffer
  @ffi.Uint32()
  external int length;

  /// < data array of size [length]
  external ffi.Pointer<ffi.Double> data;
}

/// Buffer for real data
class fmat_t extends ffi.Struct {
  /// < length of matrix
  @ffi.Uint32()
  external int length;

  /// < height of matrix
  @ffi.Uint32()
  external int height;

  /// < data array of size [length] * [height]
  external ffi.Pointer<ffi.Pointer<ffi.Float>> data;
}

class _aubio_resampler_t extends ffi.Opaque {}

class _aubio_filter_t extends ffi.Opaque {}

class _aubio_fft_t extends ffi.Opaque {}

class _aubio_dct_t extends ffi.Opaque {}

class _aubio_pvoc_t extends ffi.Opaque {}

class _aubio_filterbank_t extends ffi.Opaque {}

class _aubio_mfcc_t extends ffi.Opaque {}

class _aubio_specdesc_t extends ffi.Opaque {}

class _aubio_spectral_whitening_t extends ffi.Opaque {}

class _aubio_tss_t extends ffi.Opaque {}

class _aubio_pitch_t extends ffi.Opaque {}

class _aubio_onset_t extends ffi.Opaque {}

class _aubio_tempo_t extends ffi.Opaque {}

class _aubio_notes_t extends ffi.Opaque {}

class _aubio_source_t extends ffi.Opaque {}

class _aubio_sink_t extends ffi.Opaque {}

class _aubio_sampler_t extends ffi.Opaque {}

class _aubio_wavetable_t extends ffi.Opaque {}

class _aubio_parameter_t extends ffi.Opaque {}

/// list of logging levels
abstract class aubio_log_level {
  /// < critical errors
  static const int AUBIO_LOG_ERR = 0;

  /// < infos
  static const int AUBIO_LOG_INF = 1;

  /// < general messages
  static const int AUBIO_LOG_MSG = 2;

  /// < debug messages
  static const int AUBIO_LOG_DBG = 3;

  /// < warnings
  static const int AUBIO_LOG_WRN = 4;

  /// < number of valid levels
  static const int AUBIO_LOG_LAST_LEVEL = 5;
}

const int HAVE_AUBIO_DOUBLE = 0;

const String AUBIO_SMPL_FMT = '%f';

const String AUBIO_LSMP_FMT = '%lf';

typedef _c_new_fvec = ffi.Pointer<fvec_t> Function(
  ffi.Uint32 length,
);

typedef _dart_new_fvec = ffi.Pointer<fvec_t> Function(
  int length,
);

typedef _c_del_fvec = ffi.Void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _dart_del_fvec = void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _c_fvec_get_sample = ffi.Float Function(
  ffi.Pointer<fvec_t> s,
  ffi.Uint32 position,
);

typedef _dart_fvec_get_sample = double Function(
  ffi.Pointer<fvec_t> s,
  int position,
);

typedef _c_fvec_set_sample = ffi.Void Function(
  ffi.Pointer<fvec_t> s,
  ffi.Float data,
  ffi.Uint32 position,
);

typedef _dart_fvec_set_sample = void Function(
  ffi.Pointer<fvec_t> s,
  double data,
  int position,
);

typedef _c_fvec_get_data = ffi.Pointer<ffi.Float> Function(
  ffi.Pointer<fvec_t> s,
);

typedef _dart_fvec_get_data = ffi.Pointer<ffi.Float> Function(
  ffi.Pointer<fvec_t> s,
);

typedef _c_fvec_print = ffi.Void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _dart_fvec_print = void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _c_fvec_set_all = ffi.Void Function(
  ffi.Pointer<fvec_t> s,
  ffi.Float val,
);

typedef _dart_fvec_set_all = void Function(
  ffi.Pointer<fvec_t> s,
  double val,
);

typedef _c_fvec_zeros = ffi.Void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _dart_fvec_zeros = void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _c_fvec_ones = ffi.Void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _dart_fvec_ones = void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _c_fvec_rev = ffi.Void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _dart_fvec_rev = void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _c_fvec_weight = ffi.Void Function(
  ffi.Pointer<fvec_t> s,
  ffi.Pointer<fvec_t> weight,
);

typedef _dart_fvec_weight = void Function(
  ffi.Pointer<fvec_t> s,
  ffi.Pointer<fvec_t> weight,
);

typedef _c_fvec_copy = ffi.Void Function(
  ffi.Pointer<fvec_t> s,
  ffi.Pointer<fvec_t> t,
);

typedef _dart_fvec_copy = void Function(
  ffi.Pointer<fvec_t> s,
  ffi.Pointer<fvec_t> t,
);

typedef _c_fvec_weighted_copy = ffi.Void Function(
  ffi.Pointer<fvec_t> in_1,
  ffi.Pointer<fvec_t> weight,
  ffi.Pointer<fvec_t> out,
);

typedef _dart_fvec_weighted_copy = void Function(
  ffi.Pointer<fvec_t> in_1,
  ffi.Pointer<fvec_t> weight,
  ffi.Pointer<fvec_t> out,
);

typedef _c_new_cvec = ffi.Pointer<cvec_t> Function(
  ffi.Uint32 length,
);

typedef _dart_new_cvec = ffi.Pointer<cvec_t> Function(
  int length,
);

typedef _c_del_cvec = ffi.Void Function(
  ffi.Pointer<cvec_t> s,
);

typedef _dart_del_cvec = void Function(
  ffi.Pointer<cvec_t> s,
);

typedef _c_cvec_norm_set_sample = ffi.Void Function(
  ffi.Pointer<cvec_t> s,
  ffi.Float val,
  ffi.Uint32 position,
);

typedef _dart_cvec_norm_set_sample = void Function(
  ffi.Pointer<cvec_t> s,
  double val,
  int position,
);

typedef _c_cvec_phas_set_sample = ffi.Void Function(
  ffi.Pointer<cvec_t> s,
  ffi.Float val,
  ffi.Uint32 position,
);

typedef _dart_cvec_phas_set_sample = void Function(
  ffi.Pointer<cvec_t> s,
  double val,
  int position,
);

typedef _c_cvec_norm_get_sample = ffi.Float Function(
  ffi.Pointer<cvec_t> s,
  ffi.Uint32 position,
);

typedef _dart_cvec_norm_get_sample = double Function(
  ffi.Pointer<cvec_t> s,
  int position,
);

typedef _c_cvec_phas_get_sample = ffi.Float Function(
  ffi.Pointer<cvec_t> s,
  ffi.Uint32 position,
);

typedef _dart_cvec_phas_get_sample = double Function(
  ffi.Pointer<cvec_t> s,
  int position,
);

typedef _c_cvec_norm_get_data = ffi.Pointer<ffi.Float> Function(
  ffi.Pointer<cvec_t> s,
);

typedef _dart_cvec_norm_get_data = ffi.Pointer<ffi.Float> Function(
  ffi.Pointer<cvec_t> s,
);

typedef _c_cvec_phas_get_data = ffi.Pointer<ffi.Float> Function(
  ffi.Pointer<cvec_t> s,
);

typedef _dart_cvec_phas_get_data = ffi.Pointer<ffi.Float> Function(
  ffi.Pointer<cvec_t> s,
);

typedef _c_cvec_print = ffi.Void Function(
  ffi.Pointer<cvec_t> s,
);

typedef _dart_cvec_print = void Function(
  ffi.Pointer<cvec_t> s,
);

typedef _c_cvec_copy = ffi.Void Function(
  ffi.Pointer<cvec_t> s,
  ffi.Pointer<cvec_t> t,
);

typedef _dart_cvec_copy = void Function(
  ffi.Pointer<cvec_t> s,
  ffi.Pointer<cvec_t> t,
);

typedef _c_cvec_norm_set_all = ffi.Void Function(
  ffi.Pointer<cvec_t> s,
  ffi.Float val,
);

typedef _dart_cvec_norm_set_all = void Function(
  ffi.Pointer<cvec_t> s,
  double val,
);

typedef _c_cvec_norm_zeros = ffi.Void Function(
  ffi.Pointer<cvec_t> s,
);

typedef _dart_cvec_norm_zeros = void Function(
  ffi.Pointer<cvec_t> s,
);

typedef _c_cvec_norm_ones = ffi.Void Function(
  ffi.Pointer<cvec_t> s,
);

typedef _dart_cvec_norm_ones = void Function(
  ffi.Pointer<cvec_t> s,
);

typedef _c_cvec_phas_set_all = ffi.Void Function(
  ffi.Pointer<cvec_t> s,
  ffi.Float val,
);

typedef _dart_cvec_phas_set_all = void Function(
  ffi.Pointer<cvec_t> s,
  double val,
);

typedef _c_cvec_phas_zeros = ffi.Void Function(
  ffi.Pointer<cvec_t> s,
);

typedef _dart_cvec_phas_zeros = void Function(
  ffi.Pointer<cvec_t> s,
);

typedef _c_cvec_phas_ones = ffi.Void Function(
  ffi.Pointer<cvec_t> s,
);

typedef _dart_cvec_phas_ones = void Function(
  ffi.Pointer<cvec_t> s,
);

typedef _c_cvec_zeros = ffi.Void Function(
  ffi.Pointer<cvec_t> s,
);

typedef _dart_cvec_zeros = void Function(
  ffi.Pointer<cvec_t> s,
);

typedef _c_cvec_logmag = ffi.Void Function(
  ffi.Pointer<cvec_t> s,
  ffi.Float lambda,
);

typedef _dart_cvec_logmag = void Function(
  ffi.Pointer<cvec_t> s,
  double lambda,
);

typedef _c_new_lvec = ffi.Pointer<lvec_t> Function(
  ffi.Uint32 length,
);

typedef _dart_new_lvec = ffi.Pointer<lvec_t> Function(
  int length,
);

typedef _c_del_lvec = ffi.Void Function(
  ffi.Pointer<lvec_t> s,
);

typedef _dart_del_lvec = void Function(
  ffi.Pointer<lvec_t> s,
);

typedef _c_lvec_get_sample = ffi.Double Function(
  ffi.Pointer<lvec_t> s,
  ffi.Uint32 position,
);

typedef _dart_lvec_get_sample = double Function(
  ffi.Pointer<lvec_t> s,
  int position,
);

typedef _c_lvec_set_sample = ffi.Void Function(
  ffi.Pointer<lvec_t> s,
  ffi.Double data,
  ffi.Uint32 position,
);

typedef _dart_lvec_set_sample = void Function(
  ffi.Pointer<lvec_t> s,
  double data,
  int position,
);

typedef _c_lvec_get_data = ffi.Pointer<ffi.Double> Function(
  ffi.Pointer<lvec_t> s,
);

typedef _dart_lvec_get_data = ffi.Pointer<ffi.Double> Function(
  ffi.Pointer<lvec_t> s,
);

typedef _c_lvec_print = ffi.Void Function(
  ffi.Pointer<lvec_t> s,
);

typedef _dart_lvec_print = void Function(
  ffi.Pointer<lvec_t> s,
);

typedef _c_lvec_set_all = ffi.Void Function(
  ffi.Pointer<lvec_t> s,
  ffi.Float val,
);

typedef _dart_lvec_set_all = void Function(
  ffi.Pointer<lvec_t> s,
  double val,
);

typedef _c_lvec_zeros = ffi.Void Function(
  ffi.Pointer<lvec_t> s,
);

typedef _dart_lvec_zeros = void Function(
  ffi.Pointer<lvec_t> s,
);

typedef _c_lvec_ones = ffi.Void Function(
  ffi.Pointer<lvec_t> s,
);

typedef _dart_lvec_ones = void Function(
  ffi.Pointer<lvec_t> s,
);

typedef _c_new_fmat = ffi.Pointer<fmat_t> Function(
  ffi.Uint32 height,
  ffi.Uint32 length,
);

typedef _dart_new_fmat = ffi.Pointer<fmat_t> Function(
  int height,
  int length,
);

typedef _c_del_fmat = ffi.Void Function(
  ffi.Pointer<fmat_t> s,
);

typedef _dart_del_fmat = void Function(
  ffi.Pointer<fmat_t> s,
);

typedef _c_fmat_get_sample = ffi.Float Function(
  ffi.Pointer<fmat_t> s,
  ffi.Uint32 channel,
  ffi.Uint32 position,
);

typedef _dart_fmat_get_sample = double Function(
  ffi.Pointer<fmat_t> s,
  int channel,
  int position,
);

typedef _c_fmat_set_sample = ffi.Void Function(
  ffi.Pointer<fmat_t> s,
  ffi.Float data,
  ffi.Uint32 channel,
  ffi.Uint32 position,
);

typedef _dart_fmat_set_sample = void Function(
  ffi.Pointer<fmat_t> s,
  double data,
  int channel,
  int position,
);

typedef _c_fmat_get_channel = ffi.Void Function(
  ffi.Pointer<fmat_t> s,
  ffi.Uint32 channel,
  ffi.Pointer<fvec_t> output,
);

typedef _dart_fmat_get_channel = void Function(
  ffi.Pointer<fmat_t> s,
  int channel,
  ffi.Pointer<fvec_t> output,
);

typedef _c_fmat_get_channel_data = ffi.Pointer<ffi.Float> Function(
  ffi.Pointer<fmat_t> s,
  ffi.Uint32 channel,
);

typedef _dart_fmat_get_channel_data = ffi.Pointer<ffi.Float> Function(
  ffi.Pointer<fmat_t> s,
  int channel,
);

typedef _c_fmat_get_data = ffi.Pointer<ffi.Pointer<ffi.Float>> Function(
  ffi.Pointer<fmat_t> s,
);

typedef _dart_fmat_get_data = ffi.Pointer<ffi.Pointer<ffi.Float>> Function(
  ffi.Pointer<fmat_t> s,
);

typedef _c_fmat_print = ffi.Void Function(
  ffi.Pointer<fmat_t> s,
);

typedef _dart_fmat_print = void Function(
  ffi.Pointer<fmat_t> s,
);

typedef _c_fmat_set = ffi.Void Function(
  ffi.Pointer<fmat_t> s,
  ffi.Float val,
);

typedef _dart_fmat_set = void Function(
  ffi.Pointer<fmat_t> s,
  double val,
);

typedef _c_fmat_zeros = ffi.Void Function(
  ffi.Pointer<fmat_t> s,
);

typedef _dart_fmat_zeros = void Function(
  ffi.Pointer<fmat_t> s,
);

typedef _c_fmat_ones = ffi.Void Function(
  ffi.Pointer<fmat_t> s,
);

typedef _dart_fmat_ones = void Function(
  ffi.Pointer<fmat_t> s,
);

typedef _c_fmat_rev = ffi.Void Function(
  ffi.Pointer<fmat_t> s,
);

typedef _dart_fmat_rev = void Function(
  ffi.Pointer<fmat_t> s,
);

typedef _c_fmat_weight = ffi.Void Function(
  ffi.Pointer<fmat_t> s,
  ffi.Pointer<fmat_t> weight,
);

typedef _dart_fmat_weight = void Function(
  ffi.Pointer<fmat_t> s,
  ffi.Pointer<fmat_t> weight,
);

typedef _c_fmat_copy = ffi.Void Function(
  ffi.Pointer<fmat_t> s,
  ffi.Pointer<fmat_t> t,
);

typedef _dart_fmat_copy = void Function(
  ffi.Pointer<fmat_t> s,
  ffi.Pointer<fmat_t> t,
);

typedef _c_fmat_vecmul = ffi.Void Function(
  ffi.Pointer<fmat_t> s,
  ffi.Pointer<fvec_t> scale,
  ffi.Pointer<fvec_t> output,
);

typedef _dart_fmat_vecmul = void Function(
  ffi.Pointer<fmat_t> s,
  ffi.Pointer<fvec_t> scale,
  ffi.Pointer<fvec_t> output,
);

typedef _c_new_aubio_window = ffi.Pointer<fvec_t> Function(
  ffi.Pointer<ffi.Int8> window_type,
  ffi.Uint32 size,
);

typedef _dart_new_aubio_window = ffi.Pointer<fvec_t> Function(
  ffi.Pointer<ffi.Int8> window_type,
  int size,
);

typedef _c_fvec_set_window = ffi.Uint32 Function(
  ffi.Pointer<fvec_t> window,
  ffi.Pointer<ffi.Int8> window_type,
);

typedef _dart_fvec_set_window = int Function(
  ffi.Pointer<fvec_t> window,
  ffi.Pointer<ffi.Int8> window_type,
);

typedef _c_aubio_unwrap2pi = ffi.Float Function(
  ffi.Float phase,
);

typedef _dart_aubio_unwrap2pi = double Function(
  double phase,
);

typedef _c_aubio_bintomidi = ffi.Float Function(
  ffi.Float bin,
  ffi.Float samplerate,
  ffi.Float fftsize,
);

typedef _dart_aubio_bintomidi = double Function(
  double bin,
  double samplerate,
  double fftsize,
);

typedef _c_aubio_miditobin = ffi.Float Function(
  ffi.Float midi,
  ffi.Float samplerate,
  ffi.Float fftsize,
);

typedef _dart_aubio_miditobin = double Function(
  double midi,
  double samplerate,
  double fftsize,
);

typedef _c_aubio_bintofreq = ffi.Float Function(
  ffi.Float bin,
  ffi.Float samplerate,
  ffi.Float fftsize,
);

typedef _dart_aubio_bintofreq = double Function(
  double bin,
  double samplerate,
  double fftsize,
);

typedef _c_aubio_freqtobin = ffi.Float Function(
  ffi.Float freq,
  ffi.Float samplerate,
  ffi.Float fftsize,
);

typedef _dart_aubio_freqtobin = double Function(
  double freq,
  double samplerate,
  double fftsize,
);

typedef _c_aubio_hztomel = ffi.Float Function(
  ffi.Float freq,
);

typedef _dart_aubio_hztomel = double Function(
  double freq,
);

typedef _c_aubio_meltohz = ffi.Float Function(
  ffi.Float mel,
);

typedef _dart_aubio_meltohz = double Function(
  double mel,
);

typedef _c_aubio_hztomel_htk = ffi.Float Function(
  ffi.Float freq,
);

typedef _dart_aubio_hztomel_htk = double Function(
  double freq,
);

typedef _c_aubio_meltohz_htk = ffi.Float Function(
  ffi.Float mel,
);

typedef _dart_aubio_meltohz_htk = double Function(
  double mel,
);

typedef _c_aubio_freqtomidi = ffi.Float Function(
  ffi.Float freq,
);

typedef _dart_aubio_freqtomidi = double Function(
  double freq,
);

typedef _c_aubio_miditofreq = ffi.Float Function(
  ffi.Float midi,
);

typedef _dart_aubio_miditofreq = double Function(
  double midi,
);

typedef _c_aubio_cleanup = ffi.Void Function();

typedef _dart_aubio_cleanup = void Function();

typedef _c_aubio_zero_crossing_rate = ffi.Float Function(
  ffi.Pointer<fvec_t> v,
);

typedef _dart_aubio_zero_crossing_rate = double Function(
  ffi.Pointer<fvec_t> v,
);

typedef _c_aubio_level_lin = ffi.Float Function(
  ffi.Pointer<fvec_t> v,
);

typedef _dart_aubio_level_lin = double Function(
  ffi.Pointer<fvec_t> v,
);

typedef _c_aubio_db_spl = ffi.Float Function(
  ffi.Pointer<fvec_t> v,
);

typedef _dart_aubio_db_spl = double Function(
  ffi.Pointer<fvec_t> v,
);

typedef _c_aubio_silence_detection = ffi.Uint32 Function(
  ffi.Pointer<fvec_t> v,
  ffi.Float threshold,
);

typedef _dart_aubio_silence_detection = int Function(
  ffi.Pointer<fvec_t> v,
  double threshold,
);

typedef _c_aubio_level_detection = ffi.Float Function(
  ffi.Pointer<fvec_t> v,
  ffi.Float threshold,
);

typedef _dart_aubio_level_detection = double Function(
  ffi.Pointer<fvec_t> v,
  double threshold,
);

typedef _c_fvec_clamp = ffi.Void Function(
  ffi.Pointer<fvec_t> in_1,
  ffi.Float absmax,
);

typedef _dart_fvec_clamp = void Function(
  ffi.Pointer<fvec_t> in_1,
  double absmax,
);

typedef _c_fvec_exp = ffi.Void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _dart_fvec_exp = void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _c_fvec_cos = ffi.Void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _dart_fvec_cos = void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _c_fvec_sin = ffi.Void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _dart_fvec_sin = void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _c_fvec_abs = ffi.Void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _dart_fvec_abs = void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _c_fvec_sqrt = ffi.Void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _dart_fvec_sqrt = void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _c_fvec_log10 = ffi.Void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _dart_fvec_log10 = void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _c_fvec_log = ffi.Void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _dart_fvec_log = void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _c_fvec_floor = ffi.Void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _dart_fvec_floor = void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _c_fvec_ceil = ffi.Void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _dart_fvec_ceil = void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _c_fvec_round = ffi.Void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _dart_fvec_round = void Function(
  ffi.Pointer<fvec_t> s,
);

typedef _c_fvec_pow = ffi.Void Function(
  ffi.Pointer<fvec_t> s,
  ffi.Float pow,
);

typedef _dart_fvec_pow = void Function(
  ffi.Pointer<fvec_t> s,
  double pow,
);

typedef _c_new_aubio_resampler = ffi.Pointer<_aubio_resampler_t> Function(
  ffi.Float ratio,
  ffi.Uint32 type,
);

typedef _dart_new_aubio_resampler = ffi.Pointer<_aubio_resampler_t> Function(
  double ratio,
  int type,
);

typedef _c_del_aubio_resampler = ffi.Void Function(
  ffi.Pointer<_aubio_resampler_t> s,
);

typedef _dart_del_aubio_resampler = void Function(
  ffi.Pointer<_aubio_resampler_t> s,
);

typedef _c_aubio_resampler_do = ffi.Void Function(
  ffi.Pointer<_aubio_resampler_t> s,
  ffi.Pointer<fvec_t> input,
  ffi.Pointer<fvec_t> output,
);

typedef _dart_aubio_resampler_do = void Function(
  ffi.Pointer<_aubio_resampler_t> s,
  ffi.Pointer<fvec_t> input,
  ffi.Pointer<fvec_t> output,
);

typedef _c_aubio_filter_do = ffi.Void Function(
  ffi.Pointer<_aubio_filter_t> f,
  ffi.Pointer<fvec_t> in_1,
);

typedef _dart_aubio_filter_do = void Function(
  ffi.Pointer<_aubio_filter_t> f,
  ffi.Pointer<fvec_t> in_1,
);

typedef _c_aubio_filter_do_outplace = ffi.Void Function(
  ffi.Pointer<_aubio_filter_t> f,
  ffi.Pointer<fvec_t> in_1,
  ffi.Pointer<fvec_t> out,
);

typedef _dart_aubio_filter_do_outplace = void Function(
  ffi.Pointer<_aubio_filter_t> f,
  ffi.Pointer<fvec_t> in_1,
  ffi.Pointer<fvec_t> out,
);

typedef _c_aubio_filter_do_filtfilt = ffi.Void Function(
  ffi.Pointer<_aubio_filter_t> f,
  ffi.Pointer<fvec_t> in_1,
  ffi.Pointer<fvec_t> tmp,
);

typedef _dart_aubio_filter_do_filtfilt = void Function(
  ffi.Pointer<_aubio_filter_t> f,
  ffi.Pointer<fvec_t> in_1,
  ffi.Pointer<fvec_t> tmp,
);

typedef _c_aubio_filter_get_feedback = ffi.Pointer<lvec_t> Function(
  ffi.Pointer<_aubio_filter_t> f,
);

typedef _dart_aubio_filter_get_feedback = ffi.Pointer<lvec_t> Function(
  ffi.Pointer<_aubio_filter_t> f,
);

typedef _c_aubio_filter_get_feedforward = ffi.Pointer<lvec_t> Function(
  ffi.Pointer<_aubio_filter_t> f,
);

typedef _dart_aubio_filter_get_feedforward = ffi.Pointer<lvec_t> Function(
  ffi.Pointer<_aubio_filter_t> f,
);

typedef _c_aubio_filter_get_order = ffi.Uint32 Function(
  ffi.Pointer<_aubio_filter_t> f,
);

typedef _dart_aubio_filter_get_order = int Function(
  ffi.Pointer<_aubio_filter_t> f,
);

typedef _c_aubio_filter_get_samplerate = ffi.Uint32 Function(
  ffi.Pointer<_aubio_filter_t> f,
);

typedef _dart_aubio_filter_get_samplerate = int Function(
  ffi.Pointer<_aubio_filter_t> f,
);

typedef _c_aubio_filter_set_samplerate = ffi.Uint32 Function(
  ffi.Pointer<_aubio_filter_t> f,
  ffi.Uint32 samplerate,
);

typedef _dart_aubio_filter_set_samplerate = int Function(
  ffi.Pointer<_aubio_filter_t> f,
  int samplerate,
);

typedef _c_aubio_filter_do_reset = ffi.Void Function(
  ffi.Pointer<_aubio_filter_t> f,
);

typedef _dart_aubio_filter_do_reset = void Function(
  ffi.Pointer<_aubio_filter_t> f,
);

typedef _c_new_aubio_filter = ffi.Pointer<_aubio_filter_t> Function(
  ffi.Uint32 order,
);

typedef _dart_new_aubio_filter = ffi.Pointer<_aubio_filter_t> Function(
  int order,
);

typedef _c_del_aubio_filter = ffi.Void Function(
  ffi.Pointer<_aubio_filter_t> f,
);

typedef _dart_del_aubio_filter = void Function(
  ffi.Pointer<_aubio_filter_t> f,
);

typedef _c_aubio_filter_set_biquad = ffi.Uint32 Function(
  ffi.Pointer<_aubio_filter_t> f,
  ffi.Double b0,
  ffi.Double b1,
  ffi.Double b2,
  ffi.Double a1,
  ffi.Double a2,
);

typedef _dart_aubio_filter_set_biquad = int Function(
  ffi.Pointer<_aubio_filter_t> f,
  double b0,
  double b1,
  double b2,
  double a1,
  double a2,
);

typedef _c_new_aubio_filter_biquad = ffi.Pointer<_aubio_filter_t> Function(
  ffi.Double b0,
  ffi.Double b1,
  ffi.Double b2,
  ffi.Double a1,
  ffi.Double a2,
);

typedef _dart_new_aubio_filter_biquad = ffi.Pointer<_aubio_filter_t> Function(
  double b0,
  double b1,
  double b2,
  double a1,
  double a2,
);

typedef _c_new_aubio_filter_a_weighting = ffi.Pointer<_aubio_filter_t> Function(
  ffi.Uint32 samplerate,
);

typedef _dart_new_aubio_filter_a_weighting = ffi.Pointer<_aubio_filter_t>
    Function(
  int samplerate,
);

typedef _c_aubio_filter_set_a_weighting = ffi.Uint32 Function(
  ffi.Pointer<_aubio_filter_t> f,
  ffi.Uint32 samplerate,
);

typedef _dart_aubio_filter_set_a_weighting = int Function(
  ffi.Pointer<_aubio_filter_t> f,
  int samplerate,
);

typedef _c_new_aubio_filter_c_weighting = ffi.Pointer<_aubio_filter_t> Function(
  ffi.Uint32 samplerate,
);

typedef _dart_new_aubio_filter_c_weighting = ffi.Pointer<_aubio_filter_t>
    Function(
  int samplerate,
);

typedef _c_aubio_filter_set_c_weighting = ffi.Uint32 Function(
  ffi.Pointer<_aubio_filter_t> f,
  ffi.Uint32 samplerate,
);

typedef _dart_aubio_filter_set_c_weighting = int Function(
  ffi.Pointer<_aubio_filter_t> f,
  int samplerate,
);

typedef _c_new_aubio_fft = ffi.Pointer<_aubio_fft_t> Function(
  ffi.Uint32 size,
);

typedef _dart_new_aubio_fft = ffi.Pointer<_aubio_fft_t> Function(
  int size,
);

typedef _c_del_aubio_fft = ffi.Void Function(
  ffi.Pointer<_aubio_fft_t> s,
);

typedef _dart_del_aubio_fft = void Function(
  ffi.Pointer<_aubio_fft_t> s,
);

typedef _c_aubio_fft_do = ffi.Void Function(
  ffi.Pointer<_aubio_fft_t> s,
  ffi.Pointer<fvec_t> input,
  ffi.Pointer<cvec_t> spectrum,
);

typedef _dart_aubio_fft_do = void Function(
  ffi.Pointer<_aubio_fft_t> s,
  ffi.Pointer<fvec_t> input,
  ffi.Pointer<cvec_t> spectrum,
);

typedef _c_aubio_fft_rdo = ffi.Void Function(
  ffi.Pointer<_aubio_fft_t> s,
  ffi.Pointer<cvec_t> spectrum,
  ffi.Pointer<fvec_t> output,
);

typedef _dart_aubio_fft_rdo = void Function(
  ffi.Pointer<_aubio_fft_t> s,
  ffi.Pointer<cvec_t> spectrum,
  ffi.Pointer<fvec_t> output,
);

typedef _c_aubio_fft_do_complex = ffi.Void Function(
  ffi.Pointer<_aubio_fft_t> s,
  ffi.Pointer<fvec_t> input,
  ffi.Pointer<fvec_t> compspec,
);

typedef _dart_aubio_fft_do_complex = void Function(
  ffi.Pointer<_aubio_fft_t> s,
  ffi.Pointer<fvec_t> input,
  ffi.Pointer<fvec_t> compspec,
);

typedef _c_aubio_fft_rdo_complex = ffi.Void Function(
  ffi.Pointer<_aubio_fft_t> s,
  ffi.Pointer<fvec_t> compspec,
  ffi.Pointer<fvec_t> output,
);

typedef _dart_aubio_fft_rdo_complex = void Function(
  ffi.Pointer<_aubio_fft_t> s,
  ffi.Pointer<fvec_t> compspec,
  ffi.Pointer<fvec_t> output,
);

typedef _c_aubio_fft_get_spectrum = ffi.Void Function(
  ffi.Pointer<fvec_t> compspec,
  ffi.Pointer<cvec_t> spectrum,
);

typedef _dart_aubio_fft_get_spectrum = void Function(
  ffi.Pointer<fvec_t> compspec,
  ffi.Pointer<cvec_t> spectrum,
);

typedef _c_aubio_fft_get_realimag = ffi.Void Function(
  ffi.Pointer<cvec_t> spectrum,
  ffi.Pointer<fvec_t> compspec,
);

typedef _dart_aubio_fft_get_realimag = void Function(
  ffi.Pointer<cvec_t> spectrum,
  ffi.Pointer<fvec_t> compspec,
);

typedef _c_aubio_fft_get_phas = ffi.Void Function(
  ffi.Pointer<fvec_t> compspec,
  ffi.Pointer<cvec_t> spectrum,
);

typedef _dart_aubio_fft_get_phas = void Function(
  ffi.Pointer<fvec_t> compspec,
  ffi.Pointer<cvec_t> spectrum,
);

typedef _c_aubio_fft_get_imag = ffi.Void Function(
  ffi.Pointer<cvec_t> spectrum,
  ffi.Pointer<fvec_t> compspec,
);

typedef _dart_aubio_fft_get_imag = void Function(
  ffi.Pointer<cvec_t> spectrum,
  ffi.Pointer<fvec_t> compspec,
);

typedef _c_aubio_fft_get_norm = ffi.Void Function(
  ffi.Pointer<fvec_t> compspec,
  ffi.Pointer<cvec_t> spectrum,
);

typedef _dart_aubio_fft_get_norm = void Function(
  ffi.Pointer<fvec_t> compspec,
  ffi.Pointer<cvec_t> spectrum,
);

typedef _c_aubio_fft_get_real = ffi.Void Function(
  ffi.Pointer<cvec_t> spectrum,
  ffi.Pointer<fvec_t> compspec,
);

typedef _dart_aubio_fft_get_real = void Function(
  ffi.Pointer<cvec_t> spectrum,
  ffi.Pointer<fvec_t> compspec,
);

typedef _c_new_aubio_dct = ffi.Pointer<_aubio_dct_t> Function(
  ffi.Uint32 size,
);

typedef _dart_new_aubio_dct = ffi.Pointer<_aubio_dct_t> Function(
  int size,
);

typedef _c_aubio_dct_do = ffi.Void Function(
  ffi.Pointer<_aubio_dct_t> s,
  ffi.Pointer<fvec_t> input,
  ffi.Pointer<fvec_t> dct_output,
);

typedef _dart_aubio_dct_do = void Function(
  ffi.Pointer<_aubio_dct_t> s,
  ffi.Pointer<fvec_t> input,
  ffi.Pointer<fvec_t> dct_output,
);

typedef _c_aubio_dct_rdo = ffi.Void Function(
  ffi.Pointer<_aubio_dct_t> s,
  ffi.Pointer<fvec_t> input,
  ffi.Pointer<fvec_t> idct_output,
);

typedef _dart_aubio_dct_rdo = void Function(
  ffi.Pointer<_aubio_dct_t> s,
  ffi.Pointer<fvec_t> input,
  ffi.Pointer<fvec_t> idct_output,
);

typedef _c_del_aubio_dct = ffi.Void Function(
  ffi.Pointer<_aubio_dct_t> s,
);

typedef _dart_del_aubio_dct = void Function(
  ffi.Pointer<_aubio_dct_t> s,
);

typedef _c_new_aubio_pvoc = ffi.Pointer<_aubio_pvoc_t> Function(
  ffi.Uint32 win_s,
  ffi.Uint32 hop_s,
);

typedef _dart_new_aubio_pvoc = ffi.Pointer<_aubio_pvoc_t> Function(
  int win_s,
  int hop_s,
);

typedef _c_del_aubio_pvoc = ffi.Void Function(
  ffi.Pointer<_aubio_pvoc_t> pv,
);

typedef _dart_del_aubio_pvoc = void Function(
  ffi.Pointer<_aubio_pvoc_t> pv,
);

typedef _c_aubio_pvoc_do = ffi.Void Function(
  ffi.Pointer<_aubio_pvoc_t> pv,
  ffi.Pointer<fvec_t> in_1,
  ffi.Pointer<cvec_t> fftgrain,
);

typedef _dart_aubio_pvoc_do = void Function(
  ffi.Pointer<_aubio_pvoc_t> pv,
  ffi.Pointer<fvec_t> in_1,
  ffi.Pointer<cvec_t> fftgrain,
);

typedef _c_aubio_pvoc_rdo = ffi.Void Function(
  ffi.Pointer<_aubio_pvoc_t> pv,
  ffi.Pointer<cvec_t> fftgrain,
  ffi.Pointer<fvec_t> out,
);

typedef _dart_aubio_pvoc_rdo = void Function(
  ffi.Pointer<_aubio_pvoc_t> pv,
  ffi.Pointer<cvec_t> fftgrain,
  ffi.Pointer<fvec_t> out,
);

typedef _c_aubio_pvoc_get_win = ffi.Uint32 Function(
  ffi.Pointer<_aubio_pvoc_t> pv,
);

typedef _dart_aubio_pvoc_get_win = int Function(
  ffi.Pointer<_aubio_pvoc_t> pv,
);

typedef _c_aubio_pvoc_get_hop = ffi.Uint32 Function(
  ffi.Pointer<_aubio_pvoc_t> pv,
);

typedef _dart_aubio_pvoc_get_hop = int Function(
  ffi.Pointer<_aubio_pvoc_t> pv,
);

typedef _c_aubio_pvoc_set_window = ffi.Uint32 Function(
  ffi.Pointer<_aubio_pvoc_t> pv,
  ffi.Pointer<ffi.Int8> window_type,
);

typedef _dart_aubio_pvoc_set_window = int Function(
  ffi.Pointer<_aubio_pvoc_t> pv,
  ffi.Pointer<ffi.Int8> window_type,
);

typedef _c_new_aubio_filterbank = ffi.Pointer<_aubio_filterbank_t> Function(
  ffi.Uint32 n_filters,
  ffi.Uint32 win_s,
);

typedef _dart_new_aubio_filterbank = ffi.Pointer<_aubio_filterbank_t> Function(
  int n_filters,
  int win_s,
);

typedef _c_del_aubio_filterbank = ffi.Void Function(
  ffi.Pointer<_aubio_filterbank_t> f,
);

typedef _dart_del_aubio_filterbank = void Function(
  ffi.Pointer<_aubio_filterbank_t> f,
);

typedef _c_aubio_filterbank_do = ffi.Void Function(
  ffi.Pointer<_aubio_filterbank_t> f,
  ffi.Pointer<cvec_t> in_1,
  ffi.Pointer<fvec_t> out,
);

typedef _dart_aubio_filterbank_do = void Function(
  ffi.Pointer<_aubio_filterbank_t> f,
  ffi.Pointer<cvec_t> in_1,
  ffi.Pointer<fvec_t> out,
);

typedef _c_aubio_filterbank_get_coeffs = ffi.Pointer<fmat_t> Function(
  ffi.Pointer<_aubio_filterbank_t> f,
);

typedef _dart_aubio_filterbank_get_coeffs = ffi.Pointer<fmat_t> Function(
  ffi.Pointer<_aubio_filterbank_t> f,
);

typedef _c_aubio_filterbank_set_coeffs = ffi.Uint32 Function(
  ffi.Pointer<_aubio_filterbank_t> f,
  ffi.Pointer<fmat_t> filters,
);

typedef _dart_aubio_filterbank_set_coeffs = int Function(
  ffi.Pointer<_aubio_filterbank_t> f,
  ffi.Pointer<fmat_t> filters,
);

typedef _c_aubio_filterbank_set_norm = ffi.Uint32 Function(
  ffi.Pointer<_aubio_filterbank_t> f,
  ffi.Float norm,
);

typedef _dart_aubio_filterbank_set_norm = int Function(
  ffi.Pointer<_aubio_filterbank_t> f,
  double norm,
);

typedef _c_aubio_filterbank_get_norm = ffi.Float Function(
  ffi.Pointer<_aubio_filterbank_t> f,
);

typedef _dart_aubio_filterbank_get_norm = double Function(
  ffi.Pointer<_aubio_filterbank_t> f,
);

typedef _c_aubio_filterbank_set_power = ffi.Uint32 Function(
  ffi.Pointer<_aubio_filterbank_t> f,
  ffi.Float power,
);

typedef _dart_aubio_filterbank_set_power = int Function(
  ffi.Pointer<_aubio_filterbank_t> f,
  double power,
);

typedef _c_aubio_filterbank_get_power = ffi.Float Function(
  ffi.Pointer<_aubio_filterbank_t> f,
);

typedef _dart_aubio_filterbank_get_power = double Function(
  ffi.Pointer<_aubio_filterbank_t> f,
);

typedef _c_aubio_filterbank_set_triangle_bands = ffi.Uint32 Function(
  ffi.Pointer<_aubio_filterbank_t> fb,
  ffi.Pointer<fvec_t> freqs,
  ffi.Float samplerate,
);

typedef _dart_aubio_filterbank_set_triangle_bands = int Function(
  ffi.Pointer<_aubio_filterbank_t> fb,
  ffi.Pointer<fvec_t> freqs,
  double samplerate,
);

typedef _c_aubio_filterbank_set_mel_coeffs_slaney = ffi.Uint32 Function(
  ffi.Pointer<_aubio_filterbank_t> fb,
  ffi.Float samplerate,
);

typedef _dart_aubio_filterbank_set_mel_coeffs_slaney = int Function(
  ffi.Pointer<_aubio_filterbank_t> fb,
  double samplerate,
);

typedef _c_aubio_filterbank_set_mel_coeffs = ffi.Uint32 Function(
  ffi.Pointer<_aubio_filterbank_t> fb,
  ffi.Float samplerate,
  ffi.Float fmin,
  ffi.Float fmax,
);

typedef _dart_aubio_filterbank_set_mel_coeffs = int Function(
  ffi.Pointer<_aubio_filterbank_t> fb,
  double samplerate,
  double fmin,
  double fmax,
);

typedef _c_aubio_filterbank_set_mel_coeffs_htk = ffi.Uint32 Function(
  ffi.Pointer<_aubio_filterbank_t> fb,
  ffi.Float samplerate,
  ffi.Float fmin,
  ffi.Float fmax,
);

typedef _dart_aubio_filterbank_set_mel_coeffs_htk = int Function(
  ffi.Pointer<_aubio_filterbank_t> fb,
  double samplerate,
  double fmin,
  double fmax,
);

typedef _c_new_aubio_mfcc = ffi.Pointer<_aubio_mfcc_t> Function(
  ffi.Uint32 buf_size,
  ffi.Uint32 n_filters,
  ffi.Uint32 n_coeffs,
  ffi.Uint32 samplerate,
);

typedef _dart_new_aubio_mfcc = ffi.Pointer<_aubio_mfcc_t> Function(
  int buf_size,
  int n_filters,
  int n_coeffs,
  int samplerate,
);

typedef _c_del_aubio_mfcc = ffi.Void Function(
  ffi.Pointer<_aubio_mfcc_t> mf,
);

typedef _dart_del_aubio_mfcc = void Function(
  ffi.Pointer<_aubio_mfcc_t> mf,
);

typedef _c_aubio_mfcc_do = ffi.Void Function(
  ffi.Pointer<_aubio_mfcc_t> mf,
  ffi.Pointer<cvec_t> in_1,
  ffi.Pointer<fvec_t> out,
);

typedef _dart_aubio_mfcc_do = void Function(
  ffi.Pointer<_aubio_mfcc_t> mf,
  ffi.Pointer<cvec_t> in_1,
  ffi.Pointer<fvec_t> out,
);

typedef _c_aubio_mfcc_set_power = ffi.Uint32 Function(
  ffi.Pointer<_aubio_mfcc_t> mf,
  ffi.Float power,
);

typedef _dart_aubio_mfcc_set_power = int Function(
  ffi.Pointer<_aubio_mfcc_t> mf,
  double power,
);

typedef _c_aubio_mfcc_get_power = ffi.Float Function(
  ffi.Pointer<_aubio_mfcc_t> mf,
);

typedef _dart_aubio_mfcc_get_power = double Function(
  ffi.Pointer<_aubio_mfcc_t> mf,
);

typedef _c_aubio_mfcc_set_scale = ffi.Uint32 Function(
  ffi.Pointer<_aubio_mfcc_t> mf,
  ffi.Float scale,
);

typedef _dart_aubio_mfcc_set_scale = int Function(
  ffi.Pointer<_aubio_mfcc_t> mf,
  double scale,
);

typedef _c_aubio_mfcc_get_scale = ffi.Float Function(
  ffi.Pointer<_aubio_mfcc_t> mf,
);

typedef _dart_aubio_mfcc_get_scale = double Function(
  ffi.Pointer<_aubio_mfcc_t> mf,
);

typedef _c_aubio_mfcc_set_mel_coeffs = ffi.Uint32 Function(
  ffi.Pointer<_aubio_mfcc_t> mf,
  ffi.Float fmin,
  ffi.Float fmax,
);

typedef _dart_aubio_mfcc_set_mel_coeffs = int Function(
  ffi.Pointer<_aubio_mfcc_t> mf,
  double fmin,
  double fmax,
);

typedef _c_aubio_mfcc_set_mel_coeffs_htk = ffi.Uint32 Function(
  ffi.Pointer<_aubio_mfcc_t> mf,
  ffi.Float fmin,
  ffi.Float fmax,
);

typedef _dart_aubio_mfcc_set_mel_coeffs_htk = int Function(
  ffi.Pointer<_aubio_mfcc_t> mf,
  double fmin,
  double fmax,
);

typedef _c_aubio_mfcc_set_mel_coeffs_slaney = ffi.Uint32 Function(
  ffi.Pointer<_aubio_mfcc_t> mf,
);

typedef _dart_aubio_mfcc_set_mel_coeffs_slaney = int Function(
  ffi.Pointer<_aubio_mfcc_t> mf,
);

typedef _c_aubio_specdesc_do = ffi.Void Function(
  ffi.Pointer<_aubio_specdesc_t> o,
  ffi.Pointer<cvec_t> fftgrain,
  ffi.Pointer<fvec_t> desc,
);

typedef _dart_aubio_specdesc_do = void Function(
  ffi.Pointer<_aubio_specdesc_t> o,
  ffi.Pointer<cvec_t> fftgrain,
  ffi.Pointer<fvec_t> desc,
);

typedef _c_new_aubio_specdesc = ffi.Pointer<_aubio_specdesc_t> Function(
  ffi.Pointer<ffi.Int8> method,
  ffi.Uint32 buf_size,
);

typedef _dart_new_aubio_specdesc = ffi.Pointer<_aubio_specdesc_t> Function(
  ffi.Pointer<ffi.Int8> method,
  int buf_size,
);

typedef _c_del_aubio_specdesc = ffi.Void Function(
  ffi.Pointer<_aubio_specdesc_t> o,
);

typedef _dart_del_aubio_specdesc = void Function(
  ffi.Pointer<_aubio_specdesc_t> o,
);

typedef _c_aubio_spectral_whitening_do = ffi.Void Function(
  ffi.Pointer<_aubio_spectral_whitening_t> o,
  ffi.Pointer<cvec_t> fftgrain,
);

typedef _dart_aubio_spectral_whitening_do = void Function(
  ffi.Pointer<_aubio_spectral_whitening_t> o,
  ffi.Pointer<cvec_t> fftgrain,
);

typedef _c_new_aubio_spectral_whitening
    = ffi.Pointer<_aubio_spectral_whitening_t> Function(
  ffi.Uint32 buf_size,
  ffi.Uint32 hop_size,
  ffi.Uint32 samplerate,
);

typedef _dart_new_aubio_spectral_whitening
    = ffi.Pointer<_aubio_spectral_whitening_t> Function(
  int buf_size,
  int hop_size,
  int samplerate,
);

typedef _c_aubio_spectral_whitening_reset = ffi.Void Function(
  ffi.Pointer<_aubio_spectral_whitening_t> o,
);

typedef _dart_aubio_spectral_whitening_reset = void Function(
  ffi.Pointer<_aubio_spectral_whitening_t> o,
);

typedef _c_aubio_spectral_whitening_set_relax_time = ffi.Uint32 Function(
  ffi.Pointer<_aubio_spectral_whitening_t> o,
  ffi.Float relax_time,
);

typedef _dart_aubio_spectral_whitening_set_relax_time = int Function(
  ffi.Pointer<_aubio_spectral_whitening_t> o,
  double relax_time,
);

typedef _c_aubio_spectral_whitening_get_relax_time = ffi.Float Function(
  ffi.Pointer<_aubio_spectral_whitening_t> o,
);

typedef _dart_aubio_spectral_whitening_get_relax_time = double Function(
  ffi.Pointer<_aubio_spectral_whitening_t> o,
);

typedef _c_aubio_spectral_whitening_set_floor = ffi.Uint32 Function(
  ffi.Pointer<_aubio_spectral_whitening_t> o,
  ffi.Float floor,
);

typedef _dart_aubio_spectral_whitening_set_floor = int Function(
  ffi.Pointer<_aubio_spectral_whitening_t> o,
  double floor,
);

typedef _c_aubio_spectral_whitening_get_floor = ffi.Float Function(
  ffi.Pointer<_aubio_spectral_whitening_t> o,
);

typedef _dart_aubio_spectral_whitening_get_floor = double Function(
  ffi.Pointer<_aubio_spectral_whitening_t> o,
);

typedef _c_del_aubio_spectral_whitening = ffi.Void Function(
  ffi.Pointer<_aubio_spectral_whitening_t> o,
);

typedef _dart_del_aubio_spectral_whitening = void Function(
  ffi.Pointer<_aubio_spectral_whitening_t> o,
);

typedef _c_new_aubio_tss = ffi.Pointer<_aubio_tss_t> Function(
  ffi.Uint32 buf_size,
  ffi.Uint32 hop_size,
);

typedef _dart_new_aubio_tss = ffi.Pointer<_aubio_tss_t> Function(
  int buf_size,
  int hop_size,
);

typedef _c_del_aubio_tss = ffi.Void Function(
  ffi.Pointer<_aubio_tss_t> o,
);

typedef _dart_del_aubio_tss = void Function(
  ffi.Pointer<_aubio_tss_t> o,
);

typedef _c_aubio_tss_do = ffi.Void Function(
  ffi.Pointer<_aubio_tss_t> o,
  ffi.Pointer<cvec_t> input,
  ffi.Pointer<cvec_t> trans,
  ffi.Pointer<cvec_t> stead,
);

typedef _dart_aubio_tss_do = void Function(
  ffi.Pointer<_aubio_tss_t> o,
  ffi.Pointer<cvec_t> input,
  ffi.Pointer<cvec_t> trans,
  ffi.Pointer<cvec_t> stead,
);

typedef _c_aubio_tss_set_threshold = ffi.Uint32 Function(
  ffi.Pointer<_aubio_tss_t> o,
  ffi.Float thrs,
);

typedef _dart_aubio_tss_set_threshold = int Function(
  ffi.Pointer<_aubio_tss_t> o,
  double thrs,
);

typedef _c_aubio_tss_set_alpha = ffi.Uint32 Function(
  ffi.Pointer<_aubio_tss_t> o,
  ffi.Float alpha,
);

typedef _dart_aubio_tss_set_alpha = int Function(
  ffi.Pointer<_aubio_tss_t> o,
  double alpha,
);

typedef _c_aubio_tss_set_beta = ffi.Uint32 Function(
  ffi.Pointer<_aubio_tss_t> o,
  ffi.Float beta,
);

typedef _dart_aubio_tss_set_beta = int Function(
  ffi.Pointer<_aubio_tss_t> o,
  double beta,
);

typedef _c_aubio_pitch_do = ffi.Void Function(
  ffi.Pointer<_aubio_pitch_t> o,
  ffi.Pointer<fvec_t> in_1,
  ffi.Pointer<fvec_t> out,
);

typedef _dart_aubio_pitch_do = void Function(
  ffi.Pointer<_aubio_pitch_t> o,
  ffi.Pointer<fvec_t> in_1,
  ffi.Pointer<fvec_t> out,
);

typedef _c_aubio_pitch_set_tolerance = ffi.Uint32 Function(
  ffi.Pointer<_aubio_pitch_t> o,
  ffi.Float tol,
);

typedef _dart_aubio_pitch_set_tolerance = int Function(
  ffi.Pointer<_aubio_pitch_t> o,
  double tol,
);

typedef _c_aubio_pitch_get_tolerance = ffi.Float Function(
  ffi.Pointer<_aubio_pitch_t> o,
);

typedef _dart_aubio_pitch_get_tolerance = double Function(
  ffi.Pointer<_aubio_pitch_t> o,
);

typedef _c_del_aubio_pitch = ffi.Void Function(
  ffi.Pointer<_aubio_pitch_t> o,
);

typedef _dart_del_aubio_pitch = void Function(
  ffi.Pointer<_aubio_pitch_t> o,
);

typedef _c_new_aubio_pitch = ffi.Pointer<_aubio_pitch_t> Function(
  ffi.Pointer<ffi.Int8> method,
  ffi.Uint32 buf_size,
  ffi.Uint32 hop_size,
  ffi.Uint32 samplerate,
);

typedef _dart_new_aubio_pitch = ffi.Pointer<_aubio_pitch_t> Function(
  ffi.Pointer<ffi.Int8> method,
  int buf_size,
  int hop_size,
  int samplerate,
);

typedef _c_aubio_pitch_set_unit = ffi.Uint32 Function(
  ffi.Pointer<_aubio_pitch_t> o,
  ffi.Pointer<ffi.Int8> mode,
);

typedef _dart_aubio_pitch_set_unit = int Function(
  ffi.Pointer<_aubio_pitch_t> o,
  ffi.Pointer<ffi.Int8> mode,
);

typedef _c_aubio_pitch_set_silence = ffi.Uint32 Function(
  ffi.Pointer<_aubio_pitch_t> o,
  ffi.Float silence,
);

typedef _dart_aubio_pitch_set_silence = int Function(
  ffi.Pointer<_aubio_pitch_t> o,
  double silence,
);

typedef _c_aubio_pitch_get_silence = ffi.Float Function(
  ffi.Pointer<_aubio_pitch_t> o,
);

typedef _dart_aubio_pitch_get_silence = double Function(
  ffi.Pointer<_aubio_pitch_t> o,
);

typedef _c_aubio_pitch_get_confidence = ffi.Float Function(
  ffi.Pointer<_aubio_pitch_t> o,
);

typedef _dart_aubio_pitch_get_confidence = double Function(
  ffi.Pointer<_aubio_pitch_t> o,
);

typedef _c_new_aubio_onset = ffi.Pointer<_aubio_onset_t> Function(
  ffi.Pointer<ffi.Int8> method,
  ffi.Uint32 buf_size,
  ffi.Uint32 hop_size,
  ffi.Uint32 samplerate,
);

typedef _dart_new_aubio_onset = ffi.Pointer<_aubio_onset_t> Function(
  ffi.Pointer<ffi.Int8> method,
  int buf_size,
  int hop_size,
  int samplerate,
);

typedef _c_aubio_onset_do = ffi.Void Function(
  ffi.Pointer<_aubio_onset_t> o,
  ffi.Pointer<fvec_t> input,
  ffi.Pointer<fvec_t> onset,
);

typedef _dart_aubio_onset_do = void Function(
  ffi.Pointer<_aubio_onset_t> o,
  ffi.Pointer<fvec_t> input,
  ffi.Pointer<fvec_t> onset,
);

typedef _c_aubio_onset_get_last = ffi.Uint32 Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _dart_aubio_onset_get_last = int Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _c_aubio_onset_get_last_s = ffi.Float Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _dart_aubio_onset_get_last_s = double Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _c_aubio_onset_get_last_ms = ffi.Float Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _dart_aubio_onset_get_last_ms = double Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _c_aubio_onset_set_awhitening = ffi.Uint32 Function(
  ffi.Pointer<_aubio_onset_t> o,
  ffi.Uint32 enable,
);

typedef _dart_aubio_onset_set_awhitening = int Function(
  ffi.Pointer<_aubio_onset_t> o,
  int enable,
);

typedef _c_aubio_onset_get_awhitening = ffi.Float Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _dart_aubio_onset_get_awhitening = double Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _c_aubio_onset_set_compression = ffi.Uint32 Function(
  ffi.Pointer<_aubio_onset_t> o,
  ffi.Float lambda,
);

typedef _dart_aubio_onset_set_compression = int Function(
  ffi.Pointer<_aubio_onset_t> o,
  double lambda,
);

typedef _c_aubio_onset_get_compression = ffi.Float Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _dart_aubio_onset_get_compression = double Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _c_aubio_onset_set_silence = ffi.Uint32 Function(
  ffi.Pointer<_aubio_onset_t> o,
  ffi.Float silence,
);

typedef _dart_aubio_onset_set_silence = int Function(
  ffi.Pointer<_aubio_onset_t> o,
  double silence,
);

typedef _c_aubio_onset_get_silence = ffi.Float Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _dart_aubio_onset_get_silence = double Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _c_aubio_onset_get_descriptor = ffi.Float Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _dart_aubio_onset_get_descriptor = double Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _c_aubio_onset_get_thresholded_descriptor = ffi.Float Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _dart_aubio_onset_get_thresholded_descriptor = double Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _c_aubio_onset_set_threshold = ffi.Uint32 Function(
  ffi.Pointer<_aubio_onset_t> o,
  ffi.Float threshold,
);

typedef _dart_aubio_onset_set_threshold = int Function(
  ffi.Pointer<_aubio_onset_t> o,
  double threshold,
);

typedef _c_aubio_onset_set_minioi = ffi.Uint32 Function(
  ffi.Pointer<_aubio_onset_t> o,
  ffi.Uint32 minioi,
);

typedef _dart_aubio_onset_set_minioi = int Function(
  ffi.Pointer<_aubio_onset_t> o,
  int minioi,
);

typedef _c_aubio_onset_set_minioi_s = ffi.Uint32 Function(
  ffi.Pointer<_aubio_onset_t> o,
  ffi.Float minioi,
);

typedef _dart_aubio_onset_set_minioi_s = int Function(
  ffi.Pointer<_aubio_onset_t> o,
  double minioi,
);

typedef _c_aubio_onset_set_minioi_ms = ffi.Uint32 Function(
  ffi.Pointer<_aubio_onset_t> o,
  ffi.Float minioi,
);

typedef _dart_aubio_onset_set_minioi_ms = int Function(
  ffi.Pointer<_aubio_onset_t> o,
  double minioi,
);

typedef _c_aubio_onset_set_delay = ffi.Uint32 Function(
  ffi.Pointer<_aubio_onset_t> o,
  ffi.Uint32 delay,
);

typedef _dart_aubio_onset_set_delay = int Function(
  ffi.Pointer<_aubio_onset_t> o,
  int delay,
);

typedef _c_aubio_onset_set_delay_s = ffi.Uint32 Function(
  ffi.Pointer<_aubio_onset_t> o,
  ffi.Float delay,
);

typedef _dart_aubio_onset_set_delay_s = int Function(
  ffi.Pointer<_aubio_onset_t> o,
  double delay,
);

typedef _c_aubio_onset_set_delay_ms = ffi.Uint32 Function(
  ffi.Pointer<_aubio_onset_t> o,
  ffi.Float delay,
);

typedef _dart_aubio_onset_set_delay_ms = int Function(
  ffi.Pointer<_aubio_onset_t> o,
  double delay,
);

typedef _c_aubio_onset_get_minioi = ffi.Uint32 Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _dart_aubio_onset_get_minioi = int Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _c_aubio_onset_get_minioi_s = ffi.Float Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _dart_aubio_onset_get_minioi_s = double Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _c_aubio_onset_get_minioi_ms = ffi.Float Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _dart_aubio_onset_get_minioi_ms = double Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _c_aubio_onset_get_delay = ffi.Uint32 Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _dart_aubio_onset_get_delay = int Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _c_aubio_onset_get_delay_s = ffi.Float Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _dart_aubio_onset_get_delay_s = double Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _c_aubio_onset_get_delay_ms = ffi.Float Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _dart_aubio_onset_get_delay_ms = double Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _c_aubio_onset_get_threshold = ffi.Float Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _dart_aubio_onset_get_threshold = double Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _c_aubio_onset_set_default_parameters = ffi.Uint32 Function(
  ffi.Pointer<_aubio_onset_t> o,
  ffi.Pointer<ffi.Int8> onset_mode,
);

typedef _dart_aubio_onset_set_default_parameters = int Function(
  ffi.Pointer<_aubio_onset_t> o,
  ffi.Pointer<ffi.Int8> onset_mode,
);

typedef _c_aubio_onset_reset = ffi.Void Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _dart_aubio_onset_reset = void Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _c_del_aubio_onset = ffi.Void Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _dart_del_aubio_onset = void Function(
  ffi.Pointer<_aubio_onset_t> o,
);

typedef _c_new_aubio_tempo = ffi.Pointer<_aubio_tempo_t> Function(
  ffi.Pointer<ffi.Int8> method,
  ffi.Uint32 buf_size,
  ffi.Uint32 hop_size,
  ffi.Uint32 samplerate,
);

typedef _dart_new_aubio_tempo = ffi.Pointer<_aubio_tempo_t> Function(
  ffi.Pointer<ffi.Int8> method,
  int buf_size,
  int hop_size,
  int samplerate,
);

typedef _c_aubio_tempo_do = ffi.Void Function(
  ffi.Pointer<_aubio_tempo_t> o,
  ffi.Pointer<fvec_t> input,
  ffi.Pointer<fvec_t> tempo,
);

typedef _dart_aubio_tempo_do = void Function(
  ffi.Pointer<_aubio_tempo_t> o,
  ffi.Pointer<fvec_t> input,
  ffi.Pointer<fvec_t> tempo,
);

typedef _c_aubio_tempo_get_last = ffi.Uint32 Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _dart_aubio_tempo_get_last = int Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _c_aubio_tempo_get_last_s = ffi.Float Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _dart_aubio_tempo_get_last_s = double Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _c_aubio_tempo_get_last_ms = ffi.Float Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _dart_aubio_tempo_get_last_ms = double Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _c_aubio_tempo_set_silence = ffi.Uint32 Function(
  ffi.Pointer<_aubio_tempo_t> o,
  ffi.Float silence,
);

typedef _dart_aubio_tempo_set_silence = int Function(
  ffi.Pointer<_aubio_tempo_t> o,
  double silence,
);

typedef _c_aubio_tempo_get_silence = ffi.Float Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _dart_aubio_tempo_get_silence = double Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _c_aubio_tempo_set_threshold = ffi.Uint32 Function(
  ffi.Pointer<_aubio_tempo_t> o,
  ffi.Float threshold,
);

typedef _dart_aubio_tempo_set_threshold = int Function(
  ffi.Pointer<_aubio_tempo_t> o,
  double threshold,
);

typedef _c_aubio_tempo_get_threshold = ffi.Float Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _dart_aubio_tempo_get_threshold = double Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _c_aubio_tempo_get_period = ffi.Float Function(
  ffi.Pointer<_aubio_tempo_t> bt,
);

typedef _dart_aubio_tempo_get_period = double Function(
  ffi.Pointer<_aubio_tempo_t> bt,
);

typedef _c_aubio_tempo_get_period_s = ffi.Float Function(
  ffi.Pointer<_aubio_tempo_t> bt,
);

typedef _dart_aubio_tempo_get_period_s = double Function(
  ffi.Pointer<_aubio_tempo_t> bt,
);

typedef _c_aubio_tempo_get_bpm = ffi.Float Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _dart_aubio_tempo_get_bpm = double Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _c_aubio_tempo_get_confidence = ffi.Float Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _dart_aubio_tempo_get_confidence = double Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _c_aubio_tempo_set_tatum_signature = ffi.Uint32 Function(
  ffi.Pointer<_aubio_tempo_t> o,
  ffi.Uint32 signature,
);

typedef _dart_aubio_tempo_set_tatum_signature = int Function(
  ffi.Pointer<_aubio_tempo_t> o,
  int signature,
);

typedef _c_aubio_tempo_was_tatum = ffi.Uint32 Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _dart_aubio_tempo_was_tatum = int Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _c_aubio_tempo_get_last_tatum = ffi.Float Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _dart_aubio_tempo_get_last_tatum = double Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _c_aubio_tempo_get_delay = ffi.Uint32 Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _dart_aubio_tempo_get_delay = int Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _c_aubio_tempo_get_delay_s = ffi.Float Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _dart_aubio_tempo_get_delay_s = double Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _c_aubio_tempo_get_delay_ms = ffi.Float Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _dart_aubio_tempo_get_delay_ms = double Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _c_aubio_tempo_set_delay = ffi.Uint32 Function(
  ffi.Pointer<_aubio_tempo_t> o,
  ffi.Int32 delay,
);

typedef _dart_aubio_tempo_set_delay = int Function(
  ffi.Pointer<_aubio_tempo_t> o,
  int delay,
);

typedef _c_aubio_tempo_set_delay_s = ffi.Uint32 Function(
  ffi.Pointer<_aubio_tempo_t> o,
  ffi.Float delay,
);

typedef _dart_aubio_tempo_set_delay_s = int Function(
  ffi.Pointer<_aubio_tempo_t> o,
  double delay,
);

typedef _c_aubio_tempo_set_delay_ms = ffi.Uint32 Function(
  ffi.Pointer<_aubio_tempo_t> o,
  ffi.Float delay,
);

typedef _dart_aubio_tempo_set_delay_ms = int Function(
  ffi.Pointer<_aubio_tempo_t> o,
  double delay,
);

typedef _c_del_aubio_tempo = ffi.Void Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _dart_del_aubio_tempo = void Function(
  ffi.Pointer<_aubio_tempo_t> o,
);

typedef _c_new_aubio_notes = ffi.Pointer<_aubio_notes_t> Function(
  ffi.Pointer<ffi.Int8> method,
  ffi.Uint32 buf_size,
  ffi.Uint32 hop_size,
  ffi.Uint32 samplerate,
);

typedef _dart_new_aubio_notes = ffi.Pointer<_aubio_notes_t> Function(
  ffi.Pointer<ffi.Int8> method,
  int buf_size,
  int hop_size,
  int samplerate,
);

typedef _c_del_aubio_notes = ffi.Void Function(
  ffi.Pointer<_aubio_notes_t> o,
);

typedef _dart_del_aubio_notes = void Function(
  ffi.Pointer<_aubio_notes_t> o,
);

typedef _c_aubio_notes_do = ffi.Void Function(
  ffi.Pointer<_aubio_notes_t> o,
  ffi.Pointer<fvec_t> input,
  ffi.Pointer<fvec_t> output,
);

typedef _dart_aubio_notes_do = void Function(
  ffi.Pointer<_aubio_notes_t> o,
  ffi.Pointer<fvec_t> input,
  ffi.Pointer<fvec_t> output,
);

typedef _c_aubio_notes_set_silence = ffi.Uint32 Function(
  ffi.Pointer<_aubio_notes_t> o,
  ffi.Float silence,
);

typedef _dart_aubio_notes_set_silence = int Function(
  ffi.Pointer<_aubio_notes_t> o,
  double silence,
);

typedef _c_aubio_notes_get_silence = ffi.Float Function(
  ffi.Pointer<_aubio_notes_t> o,
);

typedef _dart_aubio_notes_get_silence = double Function(
  ffi.Pointer<_aubio_notes_t> o,
);

typedef _c_aubio_notes_get_minioi_ms = ffi.Float Function(
  ffi.Pointer<_aubio_notes_t> o,
);

typedef _dart_aubio_notes_get_minioi_ms = double Function(
  ffi.Pointer<_aubio_notes_t> o,
);

typedef _c_aubio_notes_set_minioi_ms = ffi.Uint32 Function(
  ffi.Pointer<_aubio_notes_t> o,
  ffi.Float minioi_ms,
);

typedef _dart_aubio_notes_set_minioi_ms = int Function(
  ffi.Pointer<_aubio_notes_t> o,
  double minioi_ms,
);

typedef _c_aubio_notes_get_release_drop = ffi.Float Function(
  ffi.Pointer<_aubio_notes_t> o,
);

typedef _dart_aubio_notes_get_release_drop = double Function(
  ffi.Pointer<_aubio_notes_t> o,
);

typedef _c_aubio_notes_set_release_drop = ffi.Uint32 Function(
  ffi.Pointer<_aubio_notes_t> o,
  ffi.Float release_drop,
);

typedef _dart_aubio_notes_set_release_drop = int Function(
  ffi.Pointer<_aubio_notes_t> o,
  double release_drop,
);

typedef _c_new_aubio_source = ffi.Pointer<_aubio_source_t> Function(
  ffi.Pointer<ffi.Int8> uri,
  ffi.Uint32 samplerate,
  ffi.Uint32 hop_size,
);

typedef _dart_new_aubio_source = ffi.Pointer<_aubio_source_t> Function(
  ffi.Pointer<ffi.Int8> uri,
  int samplerate,
  int hop_size,
);

typedef _c_aubio_source_do = ffi.Void Function(
  ffi.Pointer<_aubio_source_t> s,
  ffi.Pointer<fvec_t> read_to,
  ffi.Pointer<ffi.Uint32> read,
);

typedef _dart_aubio_source_do = void Function(
  ffi.Pointer<_aubio_source_t> s,
  ffi.Pointer<fvec_t> read_to,
  ffi.Pointer<ffi.Uint32> read,
);

typedef _c_aubio_source_do_multi = ffi.Void Function(
  ffi.Pointer<_aubio_source_t> s,
  ffi.Pointer<fmat_t> read_to,
  ffi.Pointer<ffi.Uint32> read,
);

typedef _dart_aubio_source_do_multi = void Function(
  ffi.Pointer<_aubio_source_t> s,
  ffi.Pointer<fmat_t> read_to,
  ffi.Pointer<ffi.Uint32> read,
);

typedef _c_aubio_source_get_samplerate = ffi.Uint32 Function(
  ffi.Pointer<_aubio_source_t> s,
);

typedef _dart_aubio_source_get_samplerate = int Function(
  ffi.Pointer<_aubio_source_t> s,
);

typedef _c_aubio_source_get_channels = ffi.Uint32 Function(
  ffi.Pointer<_aubio_source_t> s,
);

typedef _dart_aubio_source_get_channels = int Function(
  ffi.Pointer<_aubio_source_t> s,
);

typedef _c_aubio_source_seek = ffi.Uint32 Function(
  ffi.Pointer<_aubio_source_t> s,
  ffi.Uint32 pos,
);

typedef _dart_aubio_source_seek = int Function(
  ffi.Pointer<_aubio_source_t> s,
  int pos,
);

typedef _c_aubio_source_get_duration = ffi.Uint32 Function(
  ffi.Pointer<_aubio_source_t> s,
);

typedef _dart_aubio_source_get_duration = int Function(
  ffi.Pointer<_aubio_source_t> s,
);

typedef _c_aubio_source_close = ffi.Uint32 Function(
  ffi.Pointer<_aubio_source_t> s,
);

typedef _dart_aubio_source_close = int Function(
  ffi.Pointer<_aubio_source_t> s,
);

typedef _c_del_aubio_source = ffi.Void Function(
  ffi.Pointer<_aubio_source_t> s,
);

typedef _dart_del_aubio_source = void Function(
  ffi.Pointer<_aubio_source_t> s,
);

typedef _c_new_aubio_sink = ffi.Pointer<_aubio_sink_t> Function(
  ffi.Pointer<ffi.Int8> uri,
  ffi.Uint32 samplerate,
);

typedef _dart_new_aubio_sink = ffi.Pointer<_aubio_sink_t> Function(
  ffi.Pointer<ffi.Int8> uri,
  int samplerate,
);

typedef _c_aubio_sink_preset_samplerate = ffi.Uint32 Function(
  ffi.Pointer<_aubio_sink_t> s,
  ffi.Uint32 samplerate,
);

typedef _dart_aubio_sink_preset_samplerate = int Function(
  ffi.Pointer<_aubio_sink_t> s,
  int samplerate,
);

typedef _c_aubio_sink_preset_channels = ffi.Uint32 Function(
  ffi.Pointer<_aubio_sink_t> s,
  ffi.Uint32 channels,
);

typedef _dart_aubio_sink_preset_channels = int Function(
  ffi.Pointer<_aubio_sink_t> s,
  int channels,
);

typedef _c_aubio_sink_get_samplerate = ffi.Uint32 Function(
  ffi.Pointer<_aubio_sink_t> s,
);

typedef _dart_aubio_sink_get_samplerate = int Function(
  ffi.Pointer<_aubio_sink_t> s,
);

typedef _c_aubio_sink_get_channels = ffi.Uint32 Function(
  ffi.Pointer<_aubio_sink_t> s,
);

typedef _dart_aubio_sink_get_channels = int Function(
  ffi.Pointer<_aubio_sink_t> s,
);

typedef _c_aubio_sink_do = ffi.Void Function(
  ffi.Pointer<_aubio_sink_t> s,
  ffi.Pointer<fvec_t> write_data,
  ffi.Uint32 write,
);

typedef _dart_aubio_sink_do = void Function(
  ffi.Pointer<_aubio_sink_t> s,
  ffi.Pointer<fvec_t> write_data,
  int write,
);

typedef _c_aubio_sink_do_multi = ffi.Void Function(
  ffi.Pointer<_aubio_sink_t> s,
  ffi.Pointer<fmat_t> write_data,
  ffi.Uint32 write,
);

typedef _dart_aubio_sink_do_multi = void Function(
  ffi.Pointer<_aubio_sink_t> s,
  ffi.Pointer<fmat_t> write_data,
  int write,
);

typedef _c_aubio_sink_close = ffi.Uint32 Function(
  ffi.Pointer<_aubio_sink_t> s,
);

typedef _dart_aubio_sink_close = int Function(
  ffi.Pointer<_aubio_sink_t> s,
);

typedef _c_del_aubio_sink = ffi.Void Function(
  ffi.Pointer<_aubio_sink_t> s,
);

typedef _dart_del_aubio_sink = void Function(
  ffi.Pointer<_aubio_sink_t> s,
);

typedef _c_new_aubio_sampler = ffi.Pointer<_aubio_sampler_t> Function(
  ffi.Uint32 samplerate,
  ffi.Uint32 hop_size,
);

typedef _dart_new_aubio_sampler = ffi.Pointer<_aubio_sampler_t> Function(
  int samplerate,
  int hop_size,
);

typedef _c_aubio_sampler_load = ffi.Uint32 Function(
  ffi.Pointer<_aubio_sampler_t> o,
  ffi.Pointer<ffi.Int8> uri,
);

typedef _dart_aubio_sampler_load = int Function(
  ffi.Pointer<_aubio_sampler_t> o,
  ffi.Pointer<ffi.Int8> uri,
);

typedef _c_aubio_sampler_do = ffi.Void Function(
  ffi.Pointer<_aubio_sampler_t> o,
  ffi.Pointer<fvec_t> input,
  ffi.Pointer<fvec_t> output,
);

typedef _dart_aubio_sampler_do = void Function(
  ffi.Pointer<_aubio_sampler_t> o,
  ffi.Pointer<fvec_t> input,
  ffi.Pointer<fvec_t> output,
);

typedef _c_aubio_sampler_do_multi = ffi.Void Function(
  ffi.Pointer<_aubio_sampler_t> o,
  ffi.Pointer<fmat_t> input,
  ffi.Pointer<fmat_t> output,
);

typedef _dart_aubio_sampler_do_multi = void Function(
  ffi.Pointer<_aubio_sampler_t> o,
  ffi.Pointer<fmat_t> input,
  ffi.Pointer<fmat_t> output,
);

typedef _c_aubio_sampler_get_playing = ffi.Uint32 Function(
  ffi.Pointer<_aubio_sampler_t> o,
);

typedef _dart_aubio_sampler_get_playing = int Function(
  ffi.Pointer<_aubio_sampler_t> o,
);

typedef _c_aubio_sampler_set_playing = ffi.Uint32 Function(
  ffi.Pointer<_aubio_sampler_t> o,
  ffi.Uint32 playing,
);

typedef _dart_aubio_sampler_set_playing = int Function(
  ffi.Pointer<_aubio_sampler_t> o,
  int playing,
);

typedef _c_aubio_sampler_play = ffi.Uint32 Function(
  ffi.Pointer<_aubio_sampler_t> o,
);

typedef _dart_aubio_sampler_play = int Function(
  ffi.Pointer<_aubio_sampler_t> o,
);

typedef _c_aubio_sampler_stop = ffi.Uint32 Function(
  ffi.Pointer<_aubio_sampler_t> o,
);

typedef _dart_aubio_sampler_stop = int Function(
  ffi.Pointer<_aubio_sampler_t> o,
);

typedef _c_del_aubio_sampler = ffi.Void Function(
  ffi.Pointer<_aubio_sampler_t> o,
);

typedef _dart_del_aubio_sampler = void Function(
  ffi.Pointer<_aubio_sampler_t> o,
);

typedef _c_new_aubio_wavetable = ffi.Pointer<_aubio_wavetable_t> Function(
  ffi.Uint32 samplerate,
  ffi.Uint32 hop_size,
);

typedef _dart_new_aubio_wavetable = ffi.Pointer<_aubio_wavetable_t> Function(
  int samplerate,
  int hop_size,
);

typedef _c_aubio_wavetable_load = ffi.Uint32 Function(
  ffi.Pointer<_aubio_wavetable_t> o,
  ffi.Pointer<ffi.Int8> uri,
);

typedef _dart_aubio_wavetable_load = int Function(
  ffi.Pointer<_aubio_wavetable_t> o,
  ffi.Pointer<ffi.Int8> uri,
);

typedef _c_aubio_wavetable_do = ffi.Void Function(
  ffi.Pointer<_aubio_wavetable_t> o,
  ffi.Pointer<fvec_t> input,
  ffi.Pointer<fvec_t> output,
);

typedef _dart_aubio_wavetable_do = void Function(
  ffi.Pointer<_aubio_wavetable_t> o,
  ffi.Pointer<fvec_t> input,
  ffi.Pointer<fvec_t> output,
);

typedef _c_aubio_wavetable_do_multi = ffi.Void Function(
  ffi.Pointer<_aubio_wavetable_t> o,
  ffi.Pointer<fmat_t> input,
  ffi.Pointer<fmat_t> output,
);

typedef _dart_aubio_wavetable_do_multi = void Function(
  ffi.Pointer<_aubio_wavetable_t> o,
  ffi.Pointer<fmat_t> input,
  ffi.Pointer<fmat_t> output,
);

typedef _c_aubio_wavetable_get_playing = ffi.Uint32 Function(
  ffi.Pointer<_aubio_wavetable_t> o,
);

typedef _dart_aubio_wavetable_get_playing = int Function(
  ffi.Pointer<_aubio_wavetable_t> o,
);

typedef _c_aubio_wavetable_set_playing = ffi.Uint32 Function(
  ffi.Pointer<_aubio_wavetable_t> o,
  ffi.Uint32 playing,
);

typedef _dart_aubio_wavetable_set_playing = int Function(
  ffi.Pointer<_aubio_wavetable_t> o,
  int playing,
);

typedef _c_aubio_wavetable_play = ffi.Uint32 Function(
  ffi.Pointer<_aubio_wavetable_t> o,
);

typedef _dart_aubio_wavetable_play = int Function(
  ffi.Pointer<_aubio_wavetable_t> o,
);

typedef _c_aubio_wavetable_stop = ffi.Uint32 Function(
  ffi.Pointer<_aubio_wavetable_t> o,
);

typedef _dart_aubio_wavetable_stop = int Function(
  ffi.Pointer<_aubio_wavetable_t> o,
);

typedef _c_aubio_wavetable_set_freq = ffi.Uint32 Function(
  ffi.Pointer<_aubio_wavetable_t> o,
  ffi.Float freq,
);

typedef _dart_aubio_wavetable_set_freq = int Function(
  ffi.Pointer<_aubio_wavetable_t> o,
  double freq,
);

typedef _c_aubio_wavetable_get_freq = ffi.Float Function(
  ffi.Pointer<_aubio_wavetable_t> o,
);

typedef _dart_aubio_wavetable_get_freq = double Function(
  ffi.Pointer<_aubio_wavetable_t> o,
);

typedef _c_aubio_wavetable_set_amp = ffi.Uint32 Function(
  ffi.Pointer<_aubio_wavetable_t> o,
  ffi.Float amp,
);

typedef _dart_aubio_wavetable_set_amp = int Function(
  ffi.Pointer<_aubio_wavetable_t> o,
  double amp,
);

typedef _c_aubio_wavetable_get_amp = ffi.Float Function(
  ffi.Pointer<_aubio_wavetable_t> o,
);

typedef _dart_aubio_wavetable_get_amp = double Function(
  ffi.Pointer<_aubio_wavetable_t> o,
);

typedef _c_del_aubio_wavetable = ffi.Void Function(
  ffi.Pointer<_aubio_wavetable_t> o,
);

typedef _dart_del_aubio_wavetable = void Function(
  ffi.Pointer<_aubio_wavetable_t> o,
);

typedef _c_new_aubio_parameter = ffi.Pointer<_aubio_parameter_t> Function(
  ffi.Float min_value,
  ffi.Float max_value,
  ffi.Uint32 steps,
);

typedef _dart_new_aubio_parameter = ffi.Pointer<_aubio_parameter_t> Function(
  double min_value,
  double max_value,
  int steps,
);

typedef _c_aubio_parameter_set_target_value = ffi.Uint32 Function(
  ffi.Pointer<_aubio_parameter_t> param,
  ffi.Float value,
);

typedef _dart_aubio_parameter_set_target_value = int Function(
  ffi.Pointer<_aubio_parameter_t> param,
  double value,
);

typedef _c_aubio_parameter_get_next_value = ffi.Float Function(
  ffi.Pointer<_aubio_parameter_t> param,
);

typedef _dart_aubio_parameter_get_next_value = double Function(
  ffi.Pointer<_aubio_parameter_t> param,
);

typedef _c_aubio_parameter_get_current_value = ffi.Float Function(
  ffi.Pointer<_aubio_parameter_t> param,
);

typedef _dart_aubio_parameter_get_current_value = double Function(
  ffi.Pointer<_aubio_parameter_t> param,
);

typedef _c_aubio_parameter_set_current_value = ffi.Uint32 Function(
  ffi.Pointer<_aubio_parameter_t> param,
  ffi.Float value,
);

typedef _dart_aubio_parameter_set_current_value = int Function(
  ffi.Pointer<_aubio_parameter_t> param,
  double value,
);

typedef _c_aubio_parameter_set_steps = ffi.Uint32 Function(
  ffi.Pointer<_aubio_parameter_t> param,
  ffi.Uint32 steps,
);

typedef _dart_aubio_parameter_set_steps = int Function(
  ffi.Pointer<_aubio_parameter_t> param,
  int steps,
);

typedef _c_aubio_parameter_get_steps = ffi.Uint32 Function(
  ffi.Pointer<_aubio_parameter_t> param,
);

typedef _dart_aubio_parameter_get_steps = int Function(
  ffi.Pointer<_aubio_parameter_t> param,
);

typedef _c_aubio_parameter_set_min_value = ffi.Uint32 Function(
  ffi.Pointer<_aubio_parameter_t> param,
  ffi.Float min_value,
);

typedef _dart_aubio_parameter_set_min_value = int Function(
  ffi.Pointer<_aubio_parameter_t> param,
  double min_value,
);

typedef _c_aubio_parameter_get_min_value = ffi.Float Function(
  ffi.Pointer<_aubio_parameter_t> param,
);

typedef _dart_aubio_parameter_get_min_value = double Function(
  ffi.Pointer<_aubio_parameter_t> param,
);

typedef _c_aubio_parameter_set_max_value = ffi.Uint32 Function(
  ffi.Pointer<_aubio_parameter_t> param,
  ffi.Float max_value,
);

typedef _dart_aubio_parameter_set_max_value = int Function(
  ffi.Pointer<_aubio_parameter_t> param,
  double max_value,
);

typedef _c_aubio_parameter_get_max_value = ffi.Float Function(
  ffi.Pointer<_aubio_parameter_t> param,
);

typedef _dart_aubio_parameter_get_max_value = double Function(
  ffi.Pointer<_aubio_parameter_t> param,
);

typedef _c_del_aubio_parameter = ffi.Void Function(
  ffi.Pointer<_aubio_parameter_t> param,
);

typedef _dart_del_aubio_parameter = void Function(
  ffi.Pointer<_aubio_parameter_t> param,
);

typedef aubio_log_function_t = ffi.Void Function(
  ffi.Int32,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_aubio_log_set_function = ffi.Void Function(
  ffi.Pointer<ffi.NativeFunction<aubio_log_function_t>> fun,
  ffi.Pointer<ffi.Void> data,
);

typedef _dart_aubio_log_set_function = void Function(
  ffi.Pointer<ffi.NativeFunction<aubio_log_function_t>> fun,
  ffi.Pointer<ffi.Void> data,
);

typedef _c_aubio_log_set_level_function
    = ffi.Pointer<ffi.NativeFunction<aubio_log_function_t>> Function(
  ffi.Int32 level,
  ffi.Pointer<ffi.NativeFunction<aubio_log_function_t>> fun,
  ffi.Pointer<ffi.Void> data,
);

typedef _dart_aubio_log_set_level_function
    = ffi.Pointer<ffi.NativeFunction<aubio_log_function_t>> Function(
  int level,
  ffi.Pointer<ffi.NativeFunction<aubio_log_function_t>> fun,
  ffi.Pointer<ffi.Void> data,
);

typedef _c_aubio_log_reset = ffi.Void Function();

typedef _dart_aubio_log_reset = void Function();
